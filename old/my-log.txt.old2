x=4;;; There is 3 way of wrinting in skill
;; printf "The value of x is %n \n" x    ;; simplest way but wont be clear for a function of functions
;; printf("The value of x is %n \n" x)   ;; standard C-like syntax
;; (printf "The value of x is %n \n" x)  ;; standart lisp syntax, the recommend way to use it, but people usualy prefer C-like


libName = "Cells"
cellName = "inverter"
viewName = "schematic"
shapeCount = 200
printf("The design of %s %s %s is %n \n" libName cellName viewName shapeCount)

layerName= "MET_1"
purpose= "png"
rectCount= 7346546413516
labelCount= 10
lineCount=30
miscCount=50

printf(
/* "\n%-15s %-15s %-10d  %-10d  %-10d  %-10d " */
"\n%-15L %-15L %-10L  %-10L  %-10L  %-10L "
layerName
purpose
rectCount
labelCount
lineCount
miscCount
)

sprintf(cmd "echo \"%s\"" " Hello world" )
(system cmd) ;; ==> renvoie sur le shell le resultat
;; (system "xterm") ;; <== will launch an xterm, ==> wait for it to close ==> freeze

names = foreach( mapcar x i2cNames if(!listp(x) then sprintf(nil "%L\\n" x) else sprintf(nil "%L\\n" car(x)))) ;; pour les elements seul, "in"...
println(names)
sprintf(cmd "echo \"%L\"" names)
system(cmd)

aList = '(1 2 3) ;;;' quote <=> list si initialisation de la liste
aLongList = '(1 2 3 4 5 6 7 8) ;;;' quote <=> list si initialisation de la liste
aNestedList = '(1 (2 3) 4 5 (6 7)) ;;;' quote <=> list si initialisation de la liste
println( aList )
println( aLongList )
println( aNestedList )

printf("This is a liste :")

a=1 b=2
aList = list(a b)
bList = '(a b)   ;;;;  <== c'est une initialisation ==> pointeurs
a= 3
nth(0 bList)
eval(nth(0 bList))


result = '(1 2 3) ;;'
result = cons(result 1)
result = cons(1 result)  ;;<== erreur arg 1 doit etre une liste
result = cons(() 1 result)  ;;<== erreur cons a seulement 2 arguments

aList= nil
aList='()   ; equivalent'

aList=tconc(aList 1)
aList=tconc(aList 2)          	    ;; liste = tconc(liste1 liste2)
aList=tconc(aList 3)	      	    ;; ==> liste = ( (liste1 liste2) liste2)
aList=tconc(aList '(3 4 5 6)) 	    ;; tconc est mieux car il evite de creer 2 espaces memoire
println aList		      	    ;; il marche avec le pointeur sur le dernier element

result ='() for(i 0 31 result=tconc(result sprintf(nil "pad_%d" i))) result=car(result)


x0=10 y0=10  x1=10 y1=10
pinBox = list(x0:y0 x1:y1)
subst('(-10) 'y1 pinBox);==> marche pas car "list" fait un eval des valeurs pointé√é©es => pas de pointeur
subst('(-10) y1 pinBox);==> marche pas car change toutes les valeurs 10 par -10

pinBox = '(x0:y0 x1:y1)
subst('(-10) y1 pinBox) ;==> marche pas car y1 est la valeur pointé√é© par y1 et non le pointeur y1
subst('(-10) 'y1 pinBox);==> ' permet de substituer le pointeur
subst(-y1 'y1 pinBox);==> remplace y1 par -y1


numbers = '(1 2 3 ) ;;;'
	    member( 4 numbers)
;;==> (1 2 3)    ;;<== renvoie la liste, puis la ré√é©ponse : nil ou la liste troncé√é© é√é† partir de l'element cherch
;;==> nil

numbers = '(1 2 3 4 9 5 4 6) ;;;'
	    member( 4 numbers)
;;==> (1 2 3 4 9 5 4 6)
;;==> (4 9 5 4 6)
	    car(member( 4 numbers))
;;==> 4

nthelem( 2 '( a b c ) ) ;==> b

A='(1 2 1 3 1 4 1 5) B='(1 3 5)
procedure(SubstractList(B A)
let((item)
while(B && A item=car(B) B=cdr(B) A=remove(item A) )
A))
SubstractList(B A)

;; foreach( mapcar x aList ...) renvoie la liste des derniers element evalues dans ...
aList=list("one" "two" list("three"))
foreach( mapcar x aList "tata");==> ("tata" "tata" "tata")
i=0 foreach( mapcar x aList i++ );==> (0 1 2)
i=0 foreach( mapcar x aList i++ sprintf(nil "tata_%d" i));==> ("tata_1" "tata_2" "tata_3")
foreach( mapcar x aList append(list(x) '("d sd" )  )) ;==>(("one" "d sd") ("two" "d sd") (("three") "d sd"))


full='("0" "1" "2" "3" "4" "5" "6" "7" "8" "9" "10" "11" "12" "13" "14" "15")
full='(("0") ("1") ("2") ("3") ("4") ("5") ("6") ("7") ("8") ("9") ("10") ("11") ("12") ("13") ("14") ("15"))
fourth=nil
fourtt=nil
for(i 1 4 fourth=append(fourth list(car(full))) full=cdr(full))
for(i 1 4 fourtt=tconc(fourtt car(full)) full=cdr(full))
println(fourth) ;==>(("0") ("1") ("2") ("3"))
println(fourtt) ;==>((("4") ("5") ("6") ("7")) ("7"))
println(car(fourtt)) ;==>(("4") ("5") ("6") ("7")

full='(("0") ("1") ("2") ("3") ("4") ("5") ("6") ("7") ("8") ("9") ("10") ("11") ("12") ("13") ("14") ("15"))
fourtt=nil
for(i 1 4 fourtt=tconc(fourtt car(full)) full=cdr(full))
println(fourtt) ;==>((("0") ("1") ("2") ("3")) ("3"))
println(car(fourtt)) ;==>(("0") ("1") ("2") ("3"))

nthcdr( 3 '( a b c d )) ;=> (d)
z = '( 1 2 3 )
nthcdr( 2 z ); => ( 3 )

aList = '( a b c ) ;=> ( a b c )
subst( 'a 'b aList ) ;=> ( a a c )
anotherList = '( a b y ( d y ( e y )))
subst('x 'y anotherList ); => ( a b x ( d x ( e x )))

(
setof
 x
 numbers
 oddp(x)
)
help evenp ;; <=>isPaire?  |||  oddp <=> isImpaire?

'(0:0 10:10)    ;'  ==> ((X0:Y0)(X1:Y1))        <== danger ne donnera pas l effet escompte
list(0:0 10:10) ;   ==> ((X0 Y0)(X1 Y1))

one =1
two =2
three =3
moreNumbers = list( one two three)
moreNumbers

evenMoreNumbers = append( moreNumbers '(2 1)) ;;;' ))
;==> (1 2 3 2 1)

result = nil
result = cons(1 result)
result = cons(2 result)
result = cons(3 result)

reverse( result )


left = '(1 2 3)  ;; '
right = '(4 5 6) ;;'
leftRight = append(left right)
left
right


leftRight = append(left right)
rightLeft = append(right left)


cons(left right)
cons(right left)

list(7)

append(right list(7))
right
right=append(right list(7))
left =append(left list(4))

left = '(1 2 3)  ;; '
right = '(4 5 6) ;;'
cons(left right)
cons(cons(left right) right)
append(right cons(cons(left right) right))
     (println
append(right cons(left right))
     )

numbers = '(1 (2 3) ) ;;;'
type numbers
car numbers
cdr numbers
(car (cdr numbers))
(cadr numbers)
 window(3)
type  window(3)

hiGetCurrentWindow()->?
;; hiGetCurrentWindow()->stopLevel=0
hiGetWindowList

geOpen(
?lib "master"
?cell "mux2"
?view "schematic"
?mode "w"
)


alias(bk hiSetBindKey)

     view(
prependInstallPath("samples/local/schBindKeys.il")
)
    edit(
prependInstallPath("samples/local/schBindKeys.il")
)

hiSetWindowName(window(1) "Icfb")

ciwBBox = hiGetAbsWindowScreenBBox(window(1) t)

(foreach
nb_win
hiGetWindowList()
;;1 ;;; la une cest icfb dc pas besoin de la tester
;;length(hiGetWindowList())
(if
rexMatchp("Analog Design Environment" hiGetWindowName(nb_win))
hiSetWindowName(nb_win "ADE")
)
;;nb_win++
)

rexMatchp("lyopcs24" getShellEnvVar("HOSTNAME") )

rexCompile( "^[0-9]+" ) => t
rexExecute( "123abc" ) => t
rexSubstitute( "got: \\0")

nextLine="\t\t[** noise-noise **]\n"
rexExecute(nextLine)
rexCompile(".*-noise")
rexSubstitute( "got: \\0") ;=>""got:  noise-noise"


cv= geGetWindowCellView()
     ;;==> db:199725100  ;;<== database identifiant
type cv
     ;;==> dbobject
cv~>objType
     ;;==> "cellView"

cv~>?
     ;;==> donne toutes les infos des attributs possibles
     ;;==> remarques tous les attributs avec un 's' sont normalement une liste d object sauf prop
cv~>??
     ;;==> affiches les valeurs des tous les attributs
cv~>instances~>??
     ;;==> affiches toutes les infos sur les instances dans la cellview en cours
car(cv~>instances)~>?
     car(cv~>instances~>?)  ;;<== marche aussi mais

cv~>instances~>name
instId = nth(2 cv~>instances)
instId~>??

length(cv~>nets)
(cv~>netCount)   ;; egaux me semble-t-il

objId = css() ;;<== reccup l objective id de l object selectionne
objId~>prop~>name
objId~>prop~>value
objId~>test1 ;;<== si on a ajouter un attribut dans les proprietes de l object il est accessible directement par son nom ==> valable uniquement pour les usesr defined attribut

dbFindProp(cv "instances")~>value ;; <== si on a un nom d attribut identique a un nom cadence predefinit

dbFindProp(objId "instances")~>value ;
dbFindProp(objId "test1")~>value ;

cv~>terminals ;; retourne les id des nets relatifs a des pins <=> terminaux
     ;;==>(db:200079672 db:199822956 db:199822616 db:199822412)
cv~>terminals~>name
println(geGetWindowCellView()~>terminals~>name)
     ;;==>("SEL" "Y" "B" "A")
cv~>nets~>term      ;; meme chose que ci dessus mais pas forcement ds le meme ordre
(println cv~>nets~>term)
;; (db:199822616 nil nil db:199822956 db:199822412 nil nil db:200079672 nil)
pinList='()
rexCompile(">")
foreach(mapcar p cv~>terminals~>name

css() ;; alias qui retourne l id de l object selectionne (le premier de l'ensemble des selectionné√é©s c'est en fait : car(geGetSelectedSet())

dbFindTermByName( cv "SEL" )
     ;;==> db:200079672
cv~>nets~>name ;; retourne les noms de tous les nets

(println cv~>nets~>name)
     ;;==>("B" "net7" "net6" "Y" "A" "vdd!" "gnd!" "SEL" "net4")
cv~>layerPurposePairs
     ;;==>(db:200082396 db:199759444 db:199759476 db:199759508 db:199759540 db:199759572 db:199759604 db:199822340 db:199759056 )
(println     (car cv~>layerPurposePairs)~>? )
     ;;==> (cellView objType prop layerName layerNum nShapes numInstTypes purpose shapes)

(car cv~>??)

getWindowRep();; alias de geGetWindowCellView()

getWindowRep()~>instances~>?
getWindowRep()~>instances~>libNames
getWindowRep()~>instHeaders

(println (car getWindowRep()~>instHeaders) ~>? )
     ;;==>(cellView objType prop cellName instances libName master timeStamp variants viewName)
getWindowRep()~>instHeaders~>libName
getWindowRep()~>instHeaders~>libName="Ed"
     ;;<== equivaut a rename /!\ attention si plusieurs libName differents
(foreach
nb_win
getWindowRep()~>instHeaders~>libName
(if
rexMatchp("Ed" )
hiSetWindowName(nb_win "ADE")
)
;;nb_win++
)


getWindowRep()~>instHeaders~>libName
     ;;==> ("Ed" "master" "master" "master" "master" "M1_POLY1" "M1_POLY1" )
getWindowRep()~>instHeaders~>cellName
     ;;==> ("mux2" "Inv" "nand2" "M2_M1" "M2_M1" "M1_POLY1" "M1_POLY1" )
aa = setof(x getWindowRep()~>instHeaders  x~>cellName == "nand2")
     ;;==>(db:199822980)
aa~>libName = "Ed"
     ;;==> ("Ed")
myHeader = setof(x getWindowRep()~>instHeaders x~>libName == "Ed")
myHeader~>libName = "master"

     ;; si par exemple on a :
getWindowRep()~>instHeaders~>libName
     ;;==> ("master" "Ed" "master" "master" "master" "master")
     ;;alors
nth(1 getWindowRep()~>instHeaders)~>libName="master"
     ;;==>"master" ;;<== renomme en master le 2eme element


_itemsperline
     ;;==> 5 ;;<== revoie la valeur par defaut du nomre d element a afficher sur une seule ligne, qui peut etre eviter par println, mais on peux redefinir cette valeur

_itemsperline = 15 ;; <== va afficher 15 ele;ent avant de revenir a la ligne

cv= geGetWindowCellView()
cv~>instances~>name
cv~>instances~>cellName
length(cv~>shapes)
cv~>shapes~>objType

;; MENU
hiGetCIWindow ;; <=> window(1)
hiGetBannerMenus(window(1))

member('ciwOptionsMenu hiGetBannerMenus(window(1)))  ;; ' <== not egal 0 si le menu est present

member('TrRaiseCurrentWindow hiGetBannerMenus(window(1))) ;;' <== not egal 0 si le menu est present

(if (length member('TrPulldownMenu  hiGetBannerMenus(window(1))) )
 (hiDeleteBannerMenu window(1)
  (difference
   (length hiGetBannerMenus(window(1)) )
   (length  member('TrPulldownMenu  hiGetBannerMenus(window(1))))
   )
  )
)

;; CUSTOMIZATION
getSkillPath;;==> comme la var d environment PATH sous unix  ;==> ("/data/cadence/IC5.1.41_USR5/tools.lnx86/dfII/local" "." "~")
append(getSkillPath() '("~/../ebecheto/Skill/"))
setSkillPath(append(getSkillPath() '("~/../ebecheto/Skill/")))
;; mais comment faire lister les fonctions skill existantes dans les fichiers present dans le repertoire ?? foreach(file bindKeyFileList if(isFile(file) then loadi(file)))


prependInstallPath("") ;;==> "/data/cadence/IC5.1.41_USR5/tools.lnx86/dfII/"
     ;;==> equivaut presque a which icfb ;; system("which icfb") ;; /data/cadence/IC5.1.41_USR5/tools/dfII/bin/icfb


simplifyFilename("~/")
     ;;==> "/home/class9/"  ;;<== affiche le path absolu
simplifyFilename("../.")
     ;;==> "/home/class9/" ;;<==> ls  ..
simplifyFilename(".")   ;;<==> pwd

getShellEnvVar("USER")
println(getShellEnvVar("HOME"))
println(getShellEnvVar("PDK_OPT"))

;; FUNCTION PROCEDURE

;; definition de la fonction
procedure(
TrBBoxHeight(bBox)
     let( (ll ur lly ury ) ;; <== let assign a nil toutes ces variables locales
     ll= lowerLeft(bBox)
     ur= upperRight(bBox)
     lly= yCoord(ll)
     ury= xCoord(ur)
     ury - lly
     ); fin du let
     ); fin de la procedure

;; execution de la fonction
TrBBoxHeight(list( 100:100 250:390 ))

defun(bBoxWidth (bBox) caar(bBox)-caddr(bBox))


;; definition de la fonction
procedure(
TrBBoxArea(bBox)
     let( (X0 Y0 X1 Y1 area)

     X0 = xCoord(lowerLeft(bBox))
     X1 = xCoord(upperRight(bBox))

     Y0 = yCoord(lowerLeft(bBox))
     Y1 = yCoord(upperRight(bBox))

     area= (X1-X0)*(Y1-Y0)
     printf("[X0 %u] [X1 %u] [Y0 %u] [Y1 %u] of area : %u" X0 X1 Y0 Y1 area)
     area  ;;<== dernier argument est la valeure de retour
     ); fin du let
     ); fin de la procedure

;; execution de la fonction
TrBBoxArea(list( 100:120 250:390 ))

     aSquare = list(100:100 200:200)
     aHoriz  = list(100:100 250:100)
     aVert   = list(100:100 100:390)

     TrBBoxArea(aSquare)
     TrBBoxArea(aHoriz )
     TrBBoxArea(aVert  )


     var2 = 1  ;; var 2 est definit globalement
     bb = let(
(var1) var1=var2 printf("Var1 est : %u" var1)
1+1
)  ;; var1 est definit localement
     var1  ;; donc normalement et n est pas definit
     bb  ;; let revoir la valeur retournee par le derniere fonction applique


     procedure( TrEnterBoxCB( wid completed? box)
     when( completed? TrBBoxArea(box))
     ); proc

     procedure( TrEnterBox()
     enterBox(
?prompts '("First Corner" "Second Corner") ;; '
?doneProc "TrEnterBoxCB"
)
     ); proc

     hiSetBindKey("Layout" "<Key>F9" "TrEnterBox()")

     hiSetBindKeys("Command Interpreter"
     list(
    list(
 "Ctrl<Key>x"
t
;;     "(println \"hello World\")"
     "(print \"second\" )"
); EF
)
)


;; FLOW CONTROL

printf("%.30f" 1/3.0)
printf("%.17f" 1/3.0)

x=1 y=5
x<3 && y<4
x<3 && 1/0
y<4 && 1/0 ;; <== si la premiere expression est fausse le system s arrete et renvoie nil sans executer le suivant
1/0 && y<4

x<3 || y<4
x<3 || 1/0 ;; <== si la premiere expression est true => pas besion de tester la suivante


shapeType = "triangle"
case( shapeType
( "rect"
  recCount++
(println "Shape is a rectangle")
)
( "line"
  lineCount++
(println "Shape is a line")
)
( "label"
  labelCount++
(println "Shape is a label")
)
( "triangle" || "Triangle" || "TRIANGLE"
  triangleCount++
shapeType = "rect" ;; pour tester la difference avec le language C
(println "Shape is a triangle")
)
( "rect"
  recCount++
(println "Shape is a rectangle");<== ne passe pas la car break si une branche dessus est prise : different du language C
)
( t
  miscCount++
(println "Shape is a miscellaneous")
)
)

     ;; fonctions de test des types :
     numberp(3.3)
     numberp(3)
     floatp(3.3)
     floatp(3)
     fixp(3.3)
     fixp(3)
     ;; listp, stringp, symbolp, booleanp  existent aussi


; ceiling, fix, round, truncate
floor(2.2)==2.2;==> nil  ;; partie enfié√é®re
floor(2.2)==2  ;==> t
floor(15/4)==(15/4.0) ;==> nil
floor(16/4)==(16/4.0) ;==> t

(for int 1 1000
(when int==10 int=999)  ;; <== on ne peux avoir access a la var int
(println int)
)

myPort = outfile("~/Skill/time.txt")
;;time=220
time=1520
(for int 1 28
(println fprintf(myPort "%dn d %dn d %dn h %dn h \\\n" time+1 time+20 time+21 time+40))
time=time+40
)
close(myPort) myPort=nil

     ;;  symbolToString  stringToSymbol simStringsToList evalstring("3"):=>3
;; evalstring

     ( foreach element list("rect" "polygon" "path" )
     printf("[%-15s | %15s ]\n" element concat(element "Count"))
     )

rectCountx = 10
aa = "rectCountx"
evalstring(aa)

evalstring(concat("rect" "Countx")) ;; <== error
type concat("rect" "Countx") ;; en effet c est un symbol e non une string
eval(concat("rect" "Countx")) ;; <== la solution est que un simple eval suffit
type strcat("rect" "Countx")  ;; <== renvoie une string
evalstring(strcat("rect" "Countx")) ;; <== marche aussi

rectCount=0
set(   concat(element "Count")    plus( eval(concat(element "Count")) 1) )

times(1705.02 1539.0);==> 'times' est la fonction multiplier
quotient(6 2);==>3  Prefix form of the / arithmetic operator. : division

rotation = 0
rotation = mod(rotation+90 360)
sprintf(nil "R%d" rotation)

edge = 0
edge++ test = zerop(mod(edge 4)); ==> t|nil une fois tout les 4

;; une maniere d ecrire une fonction qui supprime les doublons
procedure(singleList(aList) bList=nil foreach(elt aList unless(member(elt bList) bList = append(bList list(elt) )) ) bList)
singleList(wid~>shapes~>objType)
     ;; il y a surement plus simple avec une reccursion


;;FILE I/O
;; drain(myport)  ;; <=> flush en C ==> balance le resultat du buffer
;; gets : lit ligne par ligne


;; par defaut ouvre en ecrasement de fichier
myPort = outfile("~/SKILL/FileIO/MyFile.text")
     ;;myPort = outfile("~/SKILL/FileIO/MyFile.text" "w") ;;<== write
     ;;myPort = outfile("~/SKILL/FileIO/MyFile.text" "a") ;;<== append
outportp(myPort);; <== check that the variable my_port is an output port

lineCount = 0
fprintf( myPort "Line # %d \n" lineCount++)
fprintf( myPort "Line # %d \n" lineCount++)
fprintf( myPort "Line # %d \n" lineCount++)

     close(myPort)
     myPort;; <== myport pointe toujours vers le fichier
     outportp(myPort);; <== en effet, il est toujours compris comme tel
myPort=nil	 ;; <== il peut etre une bonne idee de l annuler

while(gets(nextLine fp) printf("%s\n" nextLine )) ;; <== lit tout le fichier et l'affiche dans icfb

myPort = infile("~/SKILL/FileIO/Solutions/MyFile.text")
nextLine = nil
gets(nextLine myPort)
nextLine
gets(nextLine myPort)
nextLine
gets(nextLine myPort)
nextLine
gets(nextLine myPort)
nextLine

myPort = infile("~/SKILL/FileIO/Solutions/MyFile.text")
fscanf( myPort "%s" word)
word
fscanf( myPort "%s" word)
word
fscanf( myPort "%s" word)
word
fscanf( myPort "%s" word)
word
fscanf( myPort "%[$]" word);; <== va a la fin et ne mets pas word a jour
;;<== retoure la valeur 0 si fin de fichier, sinon fscanf retourn 1
word

wordList=nil
myPort = infile("~/SKILL/FileIO/Solutions/MyFile.text")
fscanf( myPort "%s" word)
wordList=cons(word wordList)
fscanf( myPort "%s" word)
wordList=cons(word wordList)
fscanf( myPort "%s" word)
wordList=cons(word wordList)
close(myPort)
myPort=nil

myPort = infile("~/SKILL/FileIO/Solutions/MyFile.text")
fscanf( myPort "%[^0-9]" phrase)
fscanf( myPort "%d" number) ;;<== PROBLEM ICI

while(fscanf( myPort "%d:Ctrl-C" number)
     print(number)
     )
;; <== boucle infini si le dernier caracter n est pas un chiffre


;; pp <=> pretty print a defined function that is, an existing user defined procedure
pp(s);=> pp : ls is a read protected function and cannot be pretty printed
pp(artMenuTrigger)
pp(artExitTrigger)
pp(artEnableSchematicTrigger)

cv= geGetWindowCellView()
;;wid= window(9)
wid = geGetWindowCellView()

setof( x cv~>shapes~>objType x=="rect")  ;;<== sauvegarde les attributs
setof( x cv~>shapes x~>objType=="rect")  ;;<== sauvegarde les pointeurs ==> mieux!

singleList(wid~>shapes~>objType)
foreach(mapcar x singleList(wid~>shapes~>objType) concat(x "Count"))
;;==> (textDisplayCount rectCount pathCount)

cv~>layerPurposePairs~>?
cv~>shapes~>?

foreach( mapcar x cv~>shapes x~>objType)
foreach( mapcar x cv~>shapes x~>lpp)      ;;<== layer purpose pair

foreach( mapcar x cv~>shapes cons(x~>objType x~>lpp ))
cv~>layerPurposePairs~>layerName
;;==>("nwell" "pdiff" "cont" "ndiff" "text" "metal2" "poly1" "metal1" "changedLayer")


(ddGetObj "master")~>?
(ddGetObj "master")~>cells
((ddGetObj "master")~>cells)~>?

geOpen(?lib "analogLib" ?cell "vdc" ?view "spectre" ?mode "r")
nand2wid = geOpen(?lib "master" ?cell "nand2" ?view "layout" ?mode "r")

;; Ouvre, edit et donc lock la cellule tant qu elle ne sera pas fermee ==> close needed
;; dbOpenCellViewByType( ) ;;<== pour ouvrir une database sans interface graphique
dbOpenCellViewByType( "master" "mux2" list("layout" "schematic")) ;; <= pas bon, prend le premier element qui existe uniquement
dbOpenCellViewByType( "master" "mux2" "layout" )

cellview = dbOpenCellViewByType( "master" "mux2" "layout" "" "a")


cellview~>lpps
;;==> renvoie toutes les layer purpose pairs
(car cellview~>lpps)~>?
;;==> (cellView objType prop layerName layerNum nShapes numInstTypes purpose shapes)
(car cellview~>lpps)~>purpose
;;==>"drawing"

;; cv=geGetSelSet() cv~>layerPurposePairs ;==> nil nil nil
cv=geGetWindowCellView()
cv~>lpps
nameLayer=foreach(mapcar element cv~>lpps
	cons(element~>layerName list(element~>layerNum)))
println(nameLayer)

dbClose(cellview) ;; <= ferme la cellulle
dbPurge(cellview) ;; <= ferme la cellulle et enleve les infos dans la memoire

;; dbCreateRect()

newCV = dbOpenCellViewByType( "master" "new" "layout" "maskLayout" "w")
newCV = dbOpenCellViewByType( "T2K_2008" "new" "layout" "maskLayout" "w")


newRect  = dbCreateRect(newCV "metal1" list(0:0 .5:.5))
newRect2 = dbCreateRect(newCV    30     list(0.5:0.5 1:1))

dbSave(newCV)
dbClose(newCV)

dbCreateLine( geGetWindowCellView() '("text" "drawing1") list(-0.5:100 1:100))
geTransformUserBBox(list(-0.5:100 1:100) list(0:0 "R0" 6))
dbTransformPoint( (1.5:2.5) list(0:0 "R90" 2.5) )
;=> (-6.250000 13.750000)
dbTransformPoint( (1.5:2.5) list(0:0 "R0" 2.5) ) ;; => (3.75 6.25)
dbTransformPoint( (1.5:2.5) list(0:1 "R0")) ;; => (1.5:3.5)
dbTransformBBox( '((1.5 2.5) (0 7)) list(0:1 "R0")) ;; =>  ((1.5 3.5) (0.0 8.0))


cc=car(geGetSelSet())
cc~>cellView~>??
cc~>cellName
cc~>libName
cvSym = dbOpenCellViewByType( cc~>libName cc~>cellName "symbol" "schematicSymbol" "r")
cvSch = dbOpenCellViewByType( cc~>libName cc~>cellName "schematic" "schematic" "r")
cvSch~>??
cvSch~>terminals~>??
pp=car(cvSch~>terminals~>pins)
cvSym~>signals~>??
cvSym~>pins~>??

geOpen( ?lib "master" ?cell "new"  ?view "layout" ) ;; <== check results

geSelectAll()
foreach(dbObject geGetSelSet() dbDeleteObject(dbObject))

foreach(mapcar dbObject geGetSelSet()
	foreach(mapcar inst dbObject~>conns
	inst~>name
	)
)


TrRectangles( "master" "new" "layout" list(
list("metal1" 0:0 1.0:1.5)
list("poly1" 1:1 2:3)
)
)

;; See /home/class9/SKILL/FlowOfControl/TrShapeReport.il

;; il faut parfois spé√é©cifier t_viewTypeName
ddMapGetToolNameViewType( "Composer-Schematic" ); ==>"schematic"
ddMapGetToolNameViewType( "Composer-Symbol" ) ;==>"schematicSymbol"
ddMapGetToolNameViewType( "Virtuoso" )  ;==>"maskLayout"

;;HIERARCHICAL DESIGN
mux2 = dbOpenCellViewByType( "master" "mux2" "schematic")

cv = geGetEditRep()
length(cv~>instances)

;; selectionner une instance dans Layout Editor
instId=css()
instId~>name;; <= check by "q" -> edit that it is I2
instId~>master;; <= renvoie le pointeur de l instance en question
geGetEditRep();; <= normalement c est le meme db:id  heu ?! PB



dbOpenCellViewByType( "master" "mux2" list("layout" "schematic")) ;; <= prend le premier element qui existe uniquement



mux2Layout = dbOpenCellViewByType( "master" "mux2" "layout")
mux2Sch = dbOpenCellViewByType( "master" "mux2" "schematic")
load( "HierarchyTraversal.il" )
TrSwitch(mux2Layout)  ;;<== renvoie db:iD si c'est bien un layout
TrSwitch(mux2Sch)

expandedHierarchy = TrHierarchyTraversal( mux2Layout nil )


foreach( mapcar net cv~>nets net~>name)
;;==>("SEL" "B" "A" "gnd!" "Y" "vdd!")


foreach( mapcar net cv~>nets
list(
     net~>name
     net~>instTerms
    )
)


cv = geGetEditRep()
my_netList = foreach( mapcar net cv~>nets
list(
     strcat("net : " net~>name)
     foreach( mapcar term net~>instTerms
	     list(
		  term~>name
		  term~>inst~>name
		  )
	     )
     )
)


;; open-> New-> schematic
load "~/Skill/Formation/class9/SKILL/CaseStudy/RoadMap.il"
TrRoadMap(hiGetCurrentWindow());; => create a cellView Information Model graph


cv = geGetEditRep()
x=y=0
dx=100
dy=100

my_netList = foreach( mapcar net cv~>nets
list(
     x=x+dx
     strcat("net : " net~>name)
     foreach( mapcar term net~>instTerms
	     list(
		  term~>name
		  term~>inst~>name
		  list(x y)
		  y=y+dy
		  )
	     )
     y=0
     )
)

println(my_netList)
;;==> donne une liste du genre :
tata = '(270 "net : net4" (("Y" "I1" (270 0) 10) ("A" "I0" (270 10) 20)) 0)

dbCellId = dbOpenCellViewByType( "master" "InstanceView" "layout" "maskLayout" "w")
;;dbCellId = geOpen( ?lib "master" ?cell "InstanceView"  ?view "layout" ) ;; <== check results
;;designWid = window

foreach( element my_netList
	foreach( inst  caddr(element)
		dbCreateLabel(dbCellId
			      '("text" "drawing")
			      caddr(inst)
			      strcat( cadr(inst) car(inst) )
			      "centerCenter"
			      "R0" "stick" 10.0
			      )
		)
	)
dbSave(dbCellId)
dbClose(dbCellId)
geOpen( ?lib "master" ?cell "InstanceView" ?view "layout")



procedure( TrShowProp(cv)
	  foreach( item cv~>prop
		  printf("%s" item~>name) ;;<= print without cotes ""
		  print(item~>name)       ;;<= print with cotes ""
		  println(item~>name)     ;;<= print with cotes "" and a final \n
		  )
	  t
	  )

TrShowProp(topLevelCV)


foreach( mapcar prop topLevelCV~>prop
	list( prop~>name prop~>value))

hiGetBannerMenus(window(1))
;;==> (ciwFileMenu ciwToolsMenu ciwOptionsMenu ddsvHelpMenu)



(procedure RmBannerItemByName(l_menuName @optional (window_id window(1)))
 (if (length member( l_menuName hiGetBannerMenus(window_id)) )
  (hiDeleteBannerMenu window_id
   (difference
    (length hiGetBannerMenus(window_id) )
    (length  member(l_menuName  hiGetBannerMenus(window_id)))
    )
   )
  )
 )

RmBannerItemByName('TrPulldownMenu)
RmBannerItemByName('trEdPulldownMenu)

procedure( TrCreateMenuItem( theMenuSymbol )
	  set(
	      theMenuSymbol
	      hiCreateMenuItem(
			       ?name theMenuSymbol
			       ?itemText get_pname( theMenuSymbol )
			       ?callback sprintf( nil "println('%L)" theMenuSymbol )
			       )
	      ) ;set
	  );procedure

TrCreateMenuItem('item1)
TrCreateMenuItem('item2)
TrCreateMenuItem('item3)
TrCreateMenuItem('item4)
TrCreateMenuItem('item5)


hiCreateVerticalFixedMenu(
'TrExempleVerticalFixedMenu
list(item1 item2 item3 item4 item5)
6;; number of rows
1;; number of column
)


hiDisplayFixedMenu( TrExempleVerticalFixedMenu "left"  )

attachedMenu = hiGetWindowFixedMenu()
;;==> hiFixMenu@0xbecbc08

println(attachedMenu~>?)
;;==> (fitItem zoomInItem zoomOutItem editPropItem rulerItem addedRow _doneAction _widgetInstanceList _menuItemList _orientation _cols _rows hiMenuSym)

hiRemoveFixedMenu()


hiAddFixedMenu( ?fixedMenu TrExempleVerticalFixedMenu )

hiDisplayAppBox(


hiDisplayAppDBox(
		?name gensym( 'TrDBox)
		?dboxBanner "Exemple"
		?dboxText "First\nSecond\nThird Line"
		?callback "printf(\"\nExecutinf Callback ..done\")"
		?dialogType hicInformationDialog
		?dialogStyle 'modeless
)


(procedure testType(type)
(let (text)
println(type)
sprintf(text "printf(\"Executinf Callback of %20L ..done\n\")", type )
hiDisplayAppDBox(
		?name gensym( 'TrDBox)
		?dboxBanner "Exemple"
		?dboxText "First\nSecond\nThird Line"
		?callback text
		?dialogType eval(type)
;;		?dialogType type  ;; <== si on mets type tout court ca remplace le type par sa valeur,
		?dialogStyle 'modeless
)
)
)

;;testType(hicInformationDialog)


foreach( type '(hicErrorDialog hicInformationDialog hicMessageDialog hicQuestionDialog hicWarningDialog hicWorkingDialog)
	testType(type)
	)


procedure( TrShowListBox(aList)
	  hiShowListBox(
			?name gensym( 'TrExampleListBox)
			?choices aList
			?callback 'TrExampleListBoxCB
			?title "Example List Box"
			?multipleSelect  t
			?applyButton t
			)
	  )

procedure( TrExampleListBoxCB(ok theListBox)
	  if(ok then
	     printf("You chose:\n")
	     foreach( choice theListBox->value
		     printf("%15s\n" choice)
		     )
	     else printf("You click cancel.\n")
	     )
	  )

TrShowListBox('("apple" "orange" "melon"))




;; TrFileNameField = hiCreateStringField(
;; 	?name 		'TrFileNameField
;; 	?prompt 	"File Name"
;; 	?defValue 	".cshrc"
;; 	?callback 	"TrDoFieldCheckCB( hiGetCurrentForm() )"
;; 	?editable t
;; 	)

;; hiInsertBannerMenu(window(1) TrFileNameField 8)




wf1 = TrCreateWindowForm(window(1))

for(i 1 3
;;    set(concat(wf i) 2)
    set(strcat(wf i) 2)
)


wf2 = TrCreateWindowForm(window(2))
wf5 = TrCreateWindowForm(window(5))
hiDisplayForm(wf5)


listWinIn=hiGetWindowList()
rexCompile( "Virtuoso. " )
listIn = foreach(mapcar x listWinIn
		 titleName = hiGetWindowName(x)
		 hiSetWindowName( x rexReplace( titleName "" 1) ) )



deGetAllViewTypes();;<== il n y a plus que 4 types de view type dqns la 6.1
deGetAppInfo("schematic")->menuTrigger
;;==>schMenuTrigger
deGetAppInfo("schematic")->userPostInstallTrigger
;;==>TrUserPostInstallTrigger ;; <== si

procedure(userPostInstallTriggerSch(args) let( (win titleName newTitle)
	printf("HELLO?! %s\n" hiGetCurrentWindow())
	   when( ; test sur titleName car il peut é√é™tre nil==> error rexReplace
;;		win=hiGetCurrentWindow()
		win=args->window
		titleName = hiGetWindowName(win)
		newTitle = titleName
	printf("HELLO?! %s\n" titleName)

	foreach(mapcar name '( "Virtuoso. " "Schematic Reading" "Schematic Editing")
		rexCompile(name) newTitle=rexReplace( newTitle  "" 1)
		)
	hiSetWindowName( win sprintf(nil "S%s" newTitle ))
		if(newTitle!=titleName then printf("Has removed Virtuoso\n") else printf("Has Failed\n"))
	   )));; for some Linux distrib, hiSetIconName is also needed

pp(userPostInstallTriggerSch)

if(symbolToString(deGetAppInfo("schematic")->userPostInstallTrigger)!="userPostInstallTriggerSch" then deUnRegUserTriggers("schematic"))
if(deGetAppInfo("schematic")->userPostInstallTrigger=='userPostInstallTriggerSch
	then printf("don not need to UnRegisterbecause same trigger exist\n")
	else if(deGetAppInfo("schematic")->userPostInstallTrigger==nil then printf("nothing to unRegister\n")
		else deUnRegUserTriggers("schematic")
	)
	deRegUserTriggers("schematic" nil nil 'userPostInstallTriggerSch)
	printf("Only one trigger can exist overwrite to : %s" deGetAppInfo("schematic")->userPostInstallTrigger)
)



rexCompile( "Schematic Editing" )
foreach( win listWinIn
	   when( ;; test sur titleName car il peut é√é™tre nil ==> error rexReplace
		 titleName = hiGetWindowName(win)
	   ))
rexCompile( "Schematic Reading" )
foreach( win listWinIn
	   when( ;; test sur titleName car il peut é√é™tre nil ==> error rexReplace
		 titleName = hiGetWindowName(win)
		 hiSetWindowName( win rexReplace( titleName "Sr" 1) )
		 hiSetIconName( win rexReplace( titleName "Sr" 1) );; for some Linux distrib, hiSetIconName is also needed
	   ))



;; Grrr viewType "schematic" se transforme en "analogArtist-Schematic" qd on ouvre un ADE !!
;; deGetAppInfo("analogArtist-schematic")->userPostInstallTrigger
;; deGetAppInfo("analogArtist-schematic")->userPostInstallTrigList
;; deGetAppInfo("Artist")->userPostInstallTrigger ;==> nil
deRegApp(?viewType "Artist");==> *Error* deRegApp: ViewType Artist must have a valid appName





tata = '( "Virtuoso\256 Schematic Editing: master mux2 schematic")
rexCompile( "\\256" )
rexReplace( car(tata) "" 1)
rexCompile( "Virtuoso" )
rexReplace( car(tata) "" 1)
rexCompile( "256" )
rexReplace( car(tata) "" 1)

rexCompile( "Virtuoso. " )
rexReplace( car(tata) "" 1)

rexCompile( "[Ss]chematic" )
rexReplace( car(tata) "" 0) ;==> "Virtuoso\256  Editing: master mux2 "

dir = "/data/ebecheto Sim trigger_sim3 spectre schematic"
rexCompile( "[Ss]chematic" )
rexReplace( dir "" 0) ;==> "Virtuoso\256  Editing: master mux2 "


boundp('tata)
tata = 'unbound
boundp('tata)
;;==> nil

;; si simulation parametric, les parametres sont accessible via :

selectResult('tran)~>sweepValues
;;==> ((1000.0 10000.0 100000.0) 100000.0)
car(selectResult('tran)~>sweepValues)
;;==> (1000.0 10000.0 100000.0)

if(val=car(selectResult('tran)~>sweepValues) then printf("OK-sweep\n")	else printf("PAS-OK_si pas -sweep"))

getq(selectResult('tran) sweepValues)
;==> *Error* slotValue: no such slot - sweepValues
type(ENC_SH);==> other si pas de sweep mais aussi sweep ...

sweepValues(ENC_SH);=> (1000.0 10000.0 100000.0) si parametric
sweepValues(ENC_SH);=> (10 ... 100G) <== ac steps ... si pas parametric
sweepValues(VT("/gnd!"));=> (0 ... 3u) <== tran steps ...
sweepValues(VT("/gnd!"));=(1000.0 10000.0 100000.0) <== si parametric
sweepVarValues("time");=> si pas de parametric, sinon error

className(ENC_SH);==> drWaveformIL  si pas parametric
className(ymax(ENC_SH));==>flonum   si pas parametric
className(ENC_SH);==> drWaveformIL  	  si parametric
className(ymax(ENC_SH));==>drWaveformIL   si parametric
className(VDC("/ADC_OUT<0>"));==>srrifWave si parametric

if(className(ymax(ENC_SH))=='flonum then printf("not a param") else printf("Param\n"))

;;DATA STRUCTURE

aCard = '(nil rank "ace" suit "space")
aCard->rank
aCard->suit
aCard->nouvelElement = t;; <== append en fin de list le nouvel element
aCard
aCard->?
aCard->??



cv = geGetWindowCellView()
cv = hiGetCurrentWindow()

Design->Hierarchy->Show in scope || dans IC6 : Edit->Hierarchy->Tree
caar(geGetHierMemInst(hiGetCurrentWindow()))~>??
geGetHierMemInst(hiGetCurrentWindow() ));==> list of descended schematics ((db:256626636 2)(db:tata <if multiple_nb>))
foreach(mapcar hierNb geGetHierMemInst(hiGetCurrentWindow()) printf("%s<%d>" car(hierNb)~>baseName cadr(hierNb) ))


mp=hiGetWindowFixedMenu();; <== MenuPointer

;; vire la 1ere subWindow existante de awd
awvDeleteSubwindow(window(10))

;; vire la 1ere subWindow de awd
awvDeleteSubwindow(window(10) ?subwindow 3)

awvGetCurrentSubwindow( window(10) )

awvDeleteSubwindow(
	hiGetCurrentWindow()
	?subwindow awvGetCurrentSubwindow( hiGetCurrentWindow() )
	)

gg=geGetObjectSelectedSet(geGetWindowCellView())
caar(gg)~>??
caar(gg)~>instTerms
caar(gg)~>instHeader~>??
ii = car(caar(gg)~>instTerms)
caar(gg)~>conns~>term~>??
caar(gg)~>conns~>??
car(caar(gg)~>conns)~>net~>??
car(caar(gg)~>conns)~>net~>figs~>??
caar(gg)~>pin
caar(gg)~>pin~>term->??

schHiCreateSymbolPin( "data1" "square" "inputOutput" "full" "single" 0 "left" )
schHiDrawSymbolPin( data1 "input" )

geGetWindowCellView()~>layerPurposePairs~>layerNeme="MET1"
geGetWindowCellView()~>lpps~>layerNeme="MET1"

cv=geGetWindowCellView()
setof(lpp cv~>layerPurposePairs lpp~>purpose=="MET1")

						Fonction d'acces directe a bBox
check if MET1 est au bord de la bBox                  upperLeft or uL
; println cv~>bBox => ((-0.3 0.0) (120.275 261.425))  lowerLeft or lL
; cdr(cv~>bBox)    => ((120.275 261.425))	      upperCenter or uC
((X0 Y0)(X1 Y1)) 				      lowerCenter or lC
=> X0 = caar(bBox)				      upperRight or uR
=> Y0 = cadar(cv~>bBox)				      lowerRight or lR
=> X1 = caadr(bBox)				      centerLeft or cL
=> Y1 = cadadr(cv~>bBox)			      centerCenter or cC


cv=geGetWindowCellView()
xmin=caar(cv~>bBox)
ymin=cadar(cv~>bBox)
xmax=caadr(cv~>bBox)
ymax=cadadr(cv~>bBox)
x0M1=xmax
y0M1=ymax
x1M1=xmin
y1M1=ymin
foreach(met1Lpp
	  setof(lpp geGetWindowCellView()~>layerPurposePairs lpp~>layerName=="MET1")
	(printf " ~>shapes = %L\n" met1Lpp~>shapes)
	foreach(shape met1Lpp~>shapes
		(printf "bBox = %L\n" shape~>bBox)
		x0M1=min(caar(shape~>bBox) x0M1)
		y0M1=min(cadar(shape~>bBox) y0M1)
		x1M1=max(caadr(shape~>bBox) x1M1)
		y1M1=max(cadadr(shape~>bBox) y1M1)

	         );foreach
         );foreach
x0M1=x0M1 - xmin
y0M1=y0M1 - ymin
x1M1=xmax - x1M1
y1M1=ymax - y1M1

printf("x0: left  MET1 Offset = %L\n" x0M1)
printf("y0: down  MET1 Offset = %L\n" y0M1)
printf("x1: right MET1 Offset = %L\n" x1M1)
printf("y1: top   MET1 Offset = %L\n" y1M1)

; a - b peut s'ecrire : plus(a minus(b))


offsets=let( (cv xmin ymin xmax ymax x0M1 y0M1 x1M1 y1M1)
cv=geGetWindowCellView()
xmin=caar(cv~>bBox)
ymin=cadar(cv~>bBox)
xmax=caadr(cv~>bBox)
ymax=cadadr(cv~>bBox)
x0M1=xmax
y0M1=ymax
x1M1=xmin
y1M1=ymin
foreach(met1Lpp
	  setof(lpp geGetWindowCellView()~>layerPurposePairs lpp~>layerName=="MET1")
	(printf " ~>shapes = %L\n" met1Lpp~>shapes)
	foreach(shape met1Lpp~>shapes
		(printf "bBox = %L\n" shape~>bBox)
		x0M1=min(caar(shape~>bBox) x0M1)
		y0M1=min(cadar(shape~>bBox) y0M1)
		x1M1=max(caadr(shape~>bBox) x1M1)
		y1M1=max(cadadr(shape~>bBox) y1M1)

	         );foreach
         );foreach
x0M1=x0M1 - xmin
y0M1=y0M1 - ymin
x1M1=xmax - x1M1
y1M1=ymax - y1M1
;;list((x0M1 y0M1)(x1M1 y1M1));;<== derniere ligne est le resultat renvoye;;<== ne marche pas.. comprends pas la diffé√é©rence ...
list(x0M1:y0M1 x1M1:y1M1);;<== derniere ligne est le resultat renvoye
); fin du let

leGetEntryLayer() ; <== donne la couche selectionné√é© dans LSW ; ie ==>("NW" "res")
dbCreateRect( geGetWindowCellView() list("RX" "drawing" ) list(0:0 .5:.5))
dbCreateRect( geGetWindowCellView() list( 3 "drawing" ) list(0:0 0.5:-0.5))
dbCreateLabel(geGetWindowCellView() list( 3 "drawing" ) centerBox(list(0:0 0.5:-0.5)) sprintf(nil "1") "centerCenter" "R0" "roman" 0.5)

i=1
dd=dbCreateRect( geGetWindowCellView() list( 3 "drawing" ) list(0.5*i:0 0.5*(i+1):-0.5))
dd~>layerName
dd=dbCreateRect( geGetWindowCellView() list( 125 "drawing" ) list(0.5*i:0 0.5*(i+1):-0.5))
dd~>layerName
dbCreateLabel(geGetWindowCellView() list( 3 "drawing" ) centerBox(list(0.5*i:0 0.5*(i+1):0.5)) sprintf(nil "11111") "centerLeft" "R90" "roman" 0.5)

;; A way to studdy the layer map / techfile
for(i 0 200
	elem=dbCreateRect( geGetWindowCellView() list( i "drawing" ) list(0.5*i:0 0.5*(i+1):-0.5))
	dbCreateLabel(geGetWindowCellView() list( i "drawing" ) centerBox(list(0.5*i:0 0.5*(i+1):0.5)) sprintf(nil "%d-%s" i if(elem~>layerName elem~>layerName "nil")) "centerLeft" "R90" "roman" 0.5))

for(i 0 200 	elem=dbCreateRect( geGetWindowCellView() list( i "drawing" ) list(1.0*i:0 1.0*(i+1):-1.0))
		dbCreateLabel(geGetWindowCellView() list( i "drawing" ) centerBox(list(1.0*i:0 1.0*(i+1):1.0)) sprintf(nil "%d-%s" i if(elem~>layerName elem~>layerName "nil")) "centerLeft" "R90" "roman" 1.0))

(layer \"MET1\") )

procedure(layerOffset( @optional (cv geGetWindowCellView()) (layer "MET1") )
let( (xmin ymin xmax ymax x0M1 y0M1 x1M1 y1M1) ; to use later with layerOffset(pcMaster)
xmin=caar(cv~>bBox)
ymin=cadar(cv~>bBox)
xmax=caadr(cv~>bBox)
ymax=cadadr(cv~>bBox)
x0M1=xmax
y0M1=ymax
x1M1=xmin
y1M1=ymin
foreach(met1Lpp
	  setof(lpp cv~>layerPurposePairs lpp~>layerName==layer)
	(printf " ~>shapes = %L\n" met1Lpp~>shapes)
	foreach(shape met1Lpp~>shapes
		(printf "bBox = %L\n" shape~>bBox)
		x0M1=min(caar(shape~>bBox) x0M1)
		y0M1=min(cadar(shape~>bBox) y0M1)
		x1M1=max(caadr(shape~>bBox) x1M1)
		y1M1=max(cadadr(shape~>bBox) y1M1)

	         );foreach
         );foreach
x0M1=x0M1 - xmin
y0M1=y0M1 - ymin
x1M1=xmax - x1M1
y1M1=ymax - y1M1
;;list((x0M1 y0M1)(x1M1 y1M1));;<== derniere ligne est le resultat renvoye;;<== ne marche pas.. comprends pas la diffé√é©rence ...
list(x0M1:y0M1 x1M1:y1M1);;<== derniere ligne est le resultat renvoye
); fin du let
);fin procedure


;; steepness : pente de la pente é√é† suivre pour ecarter le objets
procedure(spreadXY( @optional (cc geGetSelectedSet()) (steepness 1) (XY "Y"))
let( (xmin ymin xmax ymax csbBox step liste xn yn x0 y0)
xmin=caar(car(cc)~>bBox)
ymin=cadar(car(cc)~>bBox)
xmax=caadr(car(cc)~>bBox)
ymax=cadadr(car(cc)~>bBox)
foreach( obj cc
		(printf "bBox = %L\n" obj~>bBox)
		xmin=min(caar(obj~>bBox) xmin)
		ymin=min(cadar(obj~>bBox) ymin)
		xmax=max(caadr(obj~>bBox) xmax)
		ymax=max(cadadr(obj~>bBox) ymax)
	         );foreach
csbBox = list(xmin:ymin xmax:ymax);;<== centre de l'ensemble des objects selectinonné√é©s
cC = centerBox(csbBox)
xc = car(cC)
yc = cadr(cC)
x0 = car(centerBox(csbBox))
y0 = cadr(centerBox(csbBox))
(printf "steepness = %L\n" steepness)
if( (y0 != yc) then a = (x0-xc)/(y0-yc)*steepness else a =1)
if( (steepness==0) then ia=0 else ia = (y0-yc)/(x0-xc)/steepness)
		(printf "steepness = %L\n" steepness)
if( (XY=="X") then ;;; alignement en X
foreach( obj cc
	x0 = car(centerBox(obj~>bBox))
	y0 = cadr(centerBox(obj~>bBox))
	xn=ia*(yn-a*xc+yc)
	dbMoveFig(obj nil list(xn-x0:0 "R0"))
);end foreach
else ;; alignement en Y ;; obj=car(cc) ; PB pas de grille ...
;;a=2  list(xc yc)
foreach( obj cc
	x0 = car(centerBox(obj~>bBox))
	y0 = cadr(centerBox(obj~>bBox))
	yn=a*x0 + (yc-a*xc)
	dbMoveFig(obj nil list(0:yn-y0 "R0"))
);end foreach steepness=1
);end if
);fin du let
);fin procedure


;; cadr(cc)~>bBox=list( 0:0 0:0)  ne permet pas de dé√é©placer l'object
dbMoveFig(car(cc) nil list( 0:0 0:0)) ;<== error : invalid orient
dbMoveFig(car(cc) nil list( -1:2 "R180"))
dbMoveFig(car(cc) nil list( -1:2 "R0"));; le ne veux pas faire un move, je veux faire un place


;; projection sur un droite de pente : 'steepness' centré√é© sur l'ensemble des objets selectionné√é©s
;; steepness : pente de la pente é√é† suivre pour ecarter le objets
procedure(centerAlignXY( @optional (cc geGetSelectedSet()) (steepness 1) (XY "Y"))
let( (xmin ymin xmax ymax csbBox step liste xn yn x0 y0)
xmin=caar(car(cc)~>bBox)
ymin=cadar(car(cc)~>bBox)
xmax=caadr(car(cc)~>bBox)
ymax=cadadr(car(cc)~>bBox)
foreach( obj cc
		(printf "bBox = %L\n" obj~>bBox)
		xmin=min(caar(obj~>bBox) xmin)
		ymin=min(cadar(obj~>bBox) ymin)
		xmax=max(caadr(obj~>bBox) xmax)
		ymax=max(cadadr(obj~>bBox) ymax)
	         );foreach
csbBox = list(xmin:ymin xmax:ymax);;<== centre de l'ensemble des objects selectinonné√é©s
cC = centerBox(csbBox)
xc = car(cC)
yc = cadr(cC)
(printf "steepness = %L\n" steepness)
if( (XY=="X") then ;;; alignement en X
foreach( obj cc
when( (steepness==0)  steepness=1 printf("1/0 ?! ==> steepness re-affected to 1\n"))
	x0 = car(centerBox(obj~>bBox))
	y0 = cadr(centerBox(obj~>bBox))
	xn=(y0-yc+steepness*xc)/steepness
	dbMoveFig(obj nil list(xn-x0:0 "R0"))
);end foreach
else ;; alignement en Y ;; obj=car(cc) ; PB pas de grille ...
;;a=2  list(xc yc)
foreach( obj cc
	x0 = car(centerBox(obj~>bBox))
	y0 = cadr(centerBox(obj~>bBox))
	yn=steepness*x0 + (yc-steepness*xc)
	dbMoveFig(obj nil list(0:yn-y0 "R0"))
);end foreach steepness=1
);end if
);fin du let
);fin procedure.
; USAGE : centerAlignXY(geGetSelectedSet() 2 "X")
; USAGE : centerAlignXY(geGetSelectedSet() 1 "Y")



css()~>bBox
bb = layerOffset()
css()~>master
css()~>cellView
css()~>cellName
css()~>orient

dbCreateInst( css()~>master css()~>cellView
;; css()~>cellName ancien ou nouveau nom ? : nouveau
"toto"
list(
caar(css()~>bBox)
cadar(layerOffset()) - cadadr(layerOffset())
)
css()~>orient
)
;; ne marche pas car layerOffset() ne va pas dans la cellule !

dbCreateInst( css()~>cellView css()~>master
;; css()~>cellName ancien ou nouveau nom ? : nouveau
nil ; "toto" ;
list(
caar(css()~>bBox)
cadar(css()~>bBox) - abs( cadadr(css()~>bBox))
)
css()~>orient
)

marche pas car ne prends pas en compte l'Origin de la cellule


newInst = dbCreateInst( css()~>cellView css()~>master
;; css()~>cellName ancien ou nouveau nom ? : nouveau
nil ; "toto" ;
list(
car(css()~>xy)
; Yn = 2*Y0-Y1
2* cadar(css()~>bBox) - cadadr(css()~>bBox)
)
css()~>orient
)


;; copie n-fois de la meme instance bout a bout en Y vers le bas
selectedInst = css()
for(i 1 13
newInst = dbCreateInst( selectedInst~>cellView selectedInst~>master
nil ; "toto" ;  ~>xy donne le point d'appel de l'origine de l'instance
list(
car(selectedInst~>xy)
2* cadar(selectedInst~>bBox) - cadadr(selectedInst~>bBox)
)
selectedInst~>orient ;;"R0";;
1
)
selectedInst = newInst
)



;; **************** ;;
;; copie n-fois de la meme instance bout a bout en X vers la droite
selectedInst = css()
for(i 1 13

foreach(met1Lpp
	 setof(lpp css()~>master~>lpps lpp~>layerName=="MET4")
	(printf " ~>shapes = %L of %L\n" met1Lpp~>shapes met1Lpp~>layerName)
	foreach(shape met1Lpp~>shapes
		(printf "bBox of  = %L\n" shape~>bBox)
;;		(printf "bBox of  = %L\n" shape~>??)

	         );foreach
         );foreach


setof( css()~>master~>lpps~>layerName="MET4")

;; layerOffset(css()~>master  "MET4")
;;		css()~>instHeader
M4bBox = layerOffset(css()~>instHeader~>cellView  "MET4")
;;layerOffset(geGetWindowCellView()  "MET4")
x0 = car(selectedInst~>xy)
y0 = cadr(selectedInst~>xy)
yn = y0
xn = x0 +  caadr(M4bBox) - caar(M4bBox)
newInst = dbCreateInst( selectedInst~>cellView selectedInst~>master
nil ; "toto" ;  ~>xy donne le point d'appel de l'origine de l'instance
list(
car(selectedInst~>xy)
2* cadar(selectedInst~>bBox) - cadadr(selectedInst~>bBox)
)
selectedInst~>orient ;;"R0";;
1
)
selectedInst = newInst
)

cv=geGetWindowCellView()
ss = car(setof(inst cv~>layerPurposePairs inst~>baseName==css()~>baseName))

tfId = techGetTechFile(geGetWindowCellView())
techGetOrderedSpacingRule(tfId "minEnclosure" "metal1" "metal2")
;==> WARNING* techGetOrderedSpacingRule: Illegal layer specified "metal1".
;==> nil
techGetOrderedSpacingRule(tfId "minEnclosure" "MET1" "MET2")
;==> nil  ;<== merche ou marche pas ?

leGetValidLayerList(techGetTechFile(geGetWindowCellView()))
leSetLayerValid('("text" "drawing") t)
leSetLayerValid('("text" "drawing") nil)
assoc("text" leGetValidLayerList(techGetTechFile(geGetWindowCellView())))

leSetLayerValid('("text1" "drawing") t) ;=> Warning, Invalid

tf=techGetTechFile(geGetWindowCellView())
leIsLayerVisible('("text" "drawing") tf)

leSetLayerValid('("prBoundary" "boundary") t);<=  ?
leIsLayerValid('("prBoundary" "boundary") techGetTechFile(geGetEditCellView()))
leSetLayerValid('("prBoundary" "boundary") nil);<=  ?


let(((tf techGetTechFile(geGetEditCellView())))   setof(lpp leGetValidLayerList(tf) leIsLayerVisible(lpp tf)))



metal1 = techGetParam(tfId "metal1") ;; marche pas ? => nil
MET1 = techGetParam(tfId "MET1")     ;; marche pas ? => nil

cv =geGetEditCellView()
;cv~>libName ;cv~>cellName ;strcat("layout" ".pin")
;;newCV = dbOpenCellViewByType( "T2K_2008" "new" "layout" "maskLayout" "w")
newCV = dbOpenCellViewByType( cv~>libName cv~>cellName strcat("layout" ".pin") "maskLayout" "w")
dstFig = dbCopyFig(srcFig, dstCellView, list(0:0 "R0" 1.0))
dbSave(newCV) dbClose(newCV)


cv = geGetWindowCellView()
setof(buf  cv~>instances  buf~>cellname ==  "buffer_HM_PWS2_CL")
setof(buf  cv~>instances  buf~>cellname ==  "PA_PS")
cv~>??


when( (getShellEnvVar("HOSTNAME")=="lyopcs24") print("hihi"))

AMS_LIB = strcat(getShellEnvVar("AMS_DIR") "/artist/HK_C35")
printf( "Loading all available p-cell functions\n" )
load(strcat(AMS_LIB "/skill/ams_sdl.il"))


;; whereIs est un peu pres l'equivalent de which sous linux
whereIs(load)
;;==>Function load is a built-in primitive.
t
whereIs(whereIs)
;;==>Function whereIs is defined in file "/home/data/cmpkit/bicmos7rf_63/UNIOPUS/uniopus/5.1.41/lnx/tools/dfII/group/il/src/skillDev/help.il" at line 119.
t

whereIs(spreadXY);;==> spreadXY is not a function. ;; <== not defined
whereIs(spreadXY);;==> Function spreadXY has no source information. ;;<== had been defined in icfb
whereIs(centerAlignXY);;==> Function centerAlignXY has no source information. ;;<== had been defined in icfb with load "~/Skill/centerAlignXY.il"

asiGetNetlistDir(asiGetCurrentSession( ))   ;==> "/data/ebecheto/Sim/CRRC.sim/spectre/schematic/netlist"
asiGetAnalogRunDir(asiGetCurrentSession( )) ;==> "/data/ebecheto/Sim/CRRC.sim/spectre/schematic/netlist"
strcat(asiGetAnalogRunDir(asiGetCurrentSession( )) "/" "si.env")
asiGetCurrentSession()~>data~>??
asiGetCurrentSession()~>data~>sevSession ; <==>  (sevSession getCurrentWindow()) ==> sevSession1
asiGetCurrentSession()~>data~>plotList
cadr(cdddar(asiGetCurrentSession()~>data~>plotList));==> window:2 si plotList est une list de list. ne marche pas si c'est juste une liste

asiGetCurrentSession()~>data~>plotList~>?? ;==>*Error* get/getq: first arg must be either symbol, list, defstruct or user type - "net"
asiGetCurrentSession()->data->plotList->?? ;==> renvoie la liste correctement
length(asiGetCurrentSession()->data->plotList) ;==> 4
asiGetCurrentSession()~>data~>cellView~>??;==> renvoie vers le schematic de simulation mais pas la feneter ADE
asiGetCurrentSession()~>data~>designObj~>??;==> idem
asiGetCurrentSession()~>data~>functionNameMap~>data~>??;==> list les fonctions et leur petit nom simplifi
asiGetCurrentSession()~>data~>asiGenericVarToEnvVarTable~>??

deRegApp(?viewType "analogArtist-schematic"); ==> *Error* deRegApp: Viewtype analogArtist-schematic is already registered.
hiGetAppType(window(3)) ;==> "Artist"  si window 3 est ADE


sevOpenPlotWindow(sevSession( getCurrentWindow()));==> Ouvre une Waveform Window
awvGetWindowList();==> donne la liste des WaveformWindows ouvertes

name = "ENC_" i=0
while( isFile( filename=sprintf(nil "%s%d%s" name i ".txt")) i++)
pfile = outfile(filename)
toPrint='(ENC_OUT_V4 ENC_OUT_V4_05u ENC_OUT_V4_2u ENC_OUT_V4_4u ENC_V4_500f_2M ENC_V4_500f_4M)
( foreach element toPrint
fprintf(pfile "%s \t %L\n" element ymax(eval(element)))  ;add pwd() for IC6 
)
close(pfile)

cmd = sprintf(nil "echo %s \n cat %s ; " filename filename)
(system cmd)
startFinder() ;<== launch cdsFinder


geHiFindMarker()
_hiFormApplyCB(geFindMarkerForm)
i=0 while(geiFindMarker("next")
  i++
;  printf("bBox %L\n" hiGetViewBBox(hiGetCurrentWindow()) )
  printf("hiZoomIn(hiGetCurrentWindow() '%L )\n" hiGetViewBBox(hiGetCurrentWindow()) )
  )
printf("%d Errors\n" i)



;; erreurs de DRC renvoyé√é©s par le CMP. ne marche qu'avec 5.1.41 ..
gciDisplayMarkers(hiGetCurrentWindow());<== permet d'afficher toutes les erreurs diva dans un menu
hiGetCurrentForm(  )~>?
;; selectAll()
cv=geGetWindowCellView()
w=getCurrentWindow()
objType="marker"
;; hiZoomIn(w '((547.225 506.4) (914.45 95.4)))
db=dbMarkerQuery( cv cv~>bBox)
foreach( element db
if((length(db)==1) then printf("hiZoomIn(w '%L); %s\n"  element~>points element~>msg)
else TATA=element )
)

foreach(marker setof(element db  element~>objType=="marker")
;printf("hiZoomIn(w '%30L)\t" marker~>points)
printf("%s\n"   marker~>msg)
) t

car(db)~>??
geGetCurrentWindowHilightSet(hiGetCurrentWindow())
;; pour voir les DRC du cmp

cdsinitconfig
see plotExemple.il
help schPlot

;; plotLayoutA4toA0 :
w=getCurrentWindow()
bBox='((0 0) (-2543.9 1913.9));<== format A4, A0 doit etre (x x*sqrt(2))
bBox='((0 0) (-2706.663 1913.9))
hiResizeWindow( w list(10:-10 1280:900));<= qq chose d'a peu pres A4
hiZoomIn(w bBox)
xi=caadr(bBox)/4
yj=cadadr(bBox)/4
for(i 1 4 for(j 1 4
printf("hiZoomIn(w '((%g %g)(%g %g)))\n" (i-1)*xi (j-1)*yj i*xi j*yj)
sprintf(cmd "cat ~/lyopt.print |sed -e 's/bBox.*/bBox\t((%g %g) (%g %g))/; s/outputfile.*/outputfile\t\"A4_%d_%d.eps\"/'> tmp_%d_%d \n" i*xi (j-1)*yj (i-1)*xi j*yj i j i j )
system(cmd)
));forfor loop

for(i 1 4 for(j 1 4
printf("hiZoomIn(w '((%g %g)(%g %g)))\n" (i-1)*xi (j-1)*yj i*xi j*yj)
printf("lePlot( \"tmp_%d_%d.ps\")\n" i j))
)


for(i 1 4 for(j 1 4
lePlot( sprintf(nil "tmp_%d_%d.eps" i j))
))



http://support.cadence.com/wps/mypoc/cos?uri=deeplinkmin:ViewSolution;solutionNumber=1804793;searchHash=d2ae8b8a39e0b387d844db672f914105
http://support.cadence.com/wps/mypoc/cos?uri=deeplinkmin:ViewSolution;solutionNumber=1812032;searchHash=d2ae8b8a39e0b387d844db672f914105

; A disembodied property list is a list that starts with nil followed by alternating name/value pairs.
; Use the -> operator to retrieve a value for a given name.
; Use the -> operator together with the = operator to update or add a field.
aCard = '( nil rank "ace" suit "spades" )
aCard->rank ;=> "ace"
aCard->suit ;=> "spaces"
aCard->faceUp=t ; ==> aCard = '(nil faceUp t rank "ace" suit "spades")


getAsciiWave( t_filename x_xColumn x_yColumn [x_xskip] [x_yskip]) ; => o_wave / nil
drCreateWaveform( o_xvec o_yvec ) ;=> o_wave Creates a waveform data object with the vectors specified.

awvSimplePlotExpression( w_windowId "expr( x if(x<=T90 then 150n else 0.0 ) linRg( 0 10u 0.1u ) )" nil t )
awvPlotExpression( w_windowId "expr( x if(x<=T90 then 150n else 0.0 ) linRg( 0 3u 0.1u ) )" nil )
awvAppendExpression( w_windowId "expr( x if(x<=T90 then 150n else 0.0 ) linRg( 0 3u 0.01u ) )" nil )


plot(expr(x if(x<=T90 then 150n else 0 ) linRg(0 3u 0.01u)))
dbComputeBBox(geGetWindowCellView()) ;; if layout fit  does not fit. to check


ddGetLibList()

cell="SIOWIRE_ESD"
foreach(mapcar lib ddGetLibList()
	if((dbOpenCellViewByType lib~>name cell "layout") then break());
); pas tres bonne idé√é©e, car break appelle en fait le debugger
printf("did you find %L in %L ?" lib~>name cell)


(dbOpenCellViewByType "short_io" cell "layout")
(dbOpenCellViewByType "dummy" cell "layout")

libList=ddGetLibList()
while( ! (dbOpenCellViewByType car(libList)~>name cell "layout")
	printf("%L not found in %L\n" cell car(libList)~>name)
	libList=cdr(libList)
);end while
printf("%L found in %L\n" cell car(libList)~>name)


procedure(socketHandler(ipcId data)
  printf("%L" evalstring(data)))
ipcBeginProcess("emacs" "" 'socketHandler)
printf("Try something like :\n(send-string-to-terminal \"printf(\\\"Hello World\\\\\\n\\\")\")\nThen type t and press return\n")


inPort = infile( "~/.bashrc" )
when(inPort while(gets(nextLine inPort) println(nextLine)) close(inPort))


inPort = infile( "~/.emacs2icfb.line.il")
inPort = infile( "~/.emacs2icfb.function.il")
when(inPort while(gets(nextLine inPort)  print(evalstring(nextLine))) close(inPort))

when(inPort while(gets(nextLine inPort)  print(return(evalstring(nextLine)))) close(inPort))
; ==> *Error* return: return can only be used within a prog

procedure(socketHandler(ipcId data)
inPort = infile( data )
when(inPort while(gets(nextLine inPort)  return(print(evalstring(nextLine))) printf("\n")) close(inPort))
)
ipcBeginProcess("emacs ~/Skill/my-log.txt" "" 'socketHandler)

setPrompts(car(getPrompts( )) "@ IPNL")
setPrompts(sprintf(nil "%s %s" car(getPrompts( )) "@ IPNL CRNS/IN2P3") "@ IPNL neutrino")

pi=acos(-1);=> 3.141593
j = complex(0.0, 1.0);

ipcGetPid() ;==> renvoie le pid du process. Si tappé√é© dans icbf, renvoie ps -C icfb.exe
inPort = infile( "~/.emacs2icfb.function.il")
procedure(socketHandler(ipcId data)
inPort = infile( data )
when(inPort
	while(gets(nextLine inPort)
		print(evalstring(nextLine))
	)
	close(inPort))) ipcBeginProcess("emacs ~/Skill/my-log.txt" "" 'socketHandler)

;; region 2 schematic to gm gds
mos=css() ;; OP("/MN0","region")
mos~>name ;=> "MN0"
hier_name=eval(strcat("/" mos~>name))
OP(hier_name,"region");<== marche pas : OP est fonction Calculator ne fait pas dans l'analyse de skill
pv( "MN0" "region" ?result "dcOpInfo-info" ?resultsDir "/data/ebecheto/Sim/low_gds_sim/spectre/schematic" )

pv( mos~>name "region" ?result "dcOpInfo-info")

res = dbOpenCellViewByType( "analogLib" "res" "symbol" "schematicSymbol" "r")
;dbCreateParamInstByMasterName( d_cellView t_libName t_cellName t_viewName t_name l_origin l_orient [ x_numInst [ l_params [ b_physOnly ] ] ] )

geGetInstHier( hiGetCurrentWindow())
;; pour trouver le nom hierarchique d'une sous instance en descend edit
;; caar(geGetHierMemInst(hiGetCurrentWindow()))
hierInstName="" i=0
printf("Hierarchical Scope is :%s\n " caar(geGetHierMemInst(hiGetCurrentWindow()))~>cellView~>cellName)
foreach(mapcar hierNb geGetHierMemInst(hiGetCurrentWindow())
	hierName=car(hierNb)~>baseName
	printf("Level %d %L~>baseName:%L\n" i++ car(hierNb) hierName)
	if((hierInstName=="") then hierInstName=car(hierNb)~>baseName
			      else hierInstName=sprintf(nil "%s.%s" hierInstName car(hierNb)~>baseName))
	when(!cadr(hierNb) hierInstName=sprintf(nil "%s<%d>" hierInstName cadr(hierNb)))
) hierInstName


artGenerateHierSymbolCDF(d_cellView [g_overwrite] ) => t
artGenerateHierSymbolCDF(geGetWindowCellView())
artGenerateHierSymbolCDF(geGetEditCellView())

design("/data/ebecheto/Sim/buf_adaptivRes_sim/spectre/schematic/netlist/netlist");; OK
design("T2K_V5" "buf_adaptivRes_sim" "schematic" "a");==> nil ... PB
design( t_cktFile | t_lib t_cell t_view [t_mode])
hcv=caar(geGetHierMemInst(hiGetCurrentWindow()))~>cellView
hcv=geGetWindowCellView();; si pas de descend edit
design( hcv~>libName hcv~>cellName hcv~>viewName )
design(caar(geGetHierMemInst(hiGetCurrentWindow()))~>cellView~>fileName)


((lambda (arg) (plus car(arg) cadr(arg) )) list(1 2) ) ;; effectue la somme des element de la liste en argument

((lambda ('(arg1 arg2)) (plus arg1 arg2 )) list(1 2) )

((lambda (arg) (append list(caar(arg)+caadr(arg)) list(cadar(arg)+ cadadr(arg)) )) list(list(1 2) list(2 3) ) ) ;<== additione une liste membre a membre
((lambda (arg) (append list(caar(arg)+car(cadr(myList))) list(car(cdar(arg))+cadr(cadr(myList))) )) list(list(1 2) list(3 4) ) ) ;<== additione une liste membre a membre

myList=list(list(1 2) list(3 4) ) t
caar(myList)
car(cdar(myList))
car(cadr(myList))
cadr(cadr(myList))

ouvrir fenetre parametric :
par=sevParametricTool(hiGetCurrentWindow()->sevSession)
par~>??
par->paraplotTool->??

enterPoint();<== permet de ré√é©ccupé√é©rer les coordonné√é©es d'un point en cliquant dans une fenetre; ==> i.e. : (1705.02 1539.0)

TODO : learn howto toggle and apply (remouve boundary)
leiToggleValidCB( 480:1430 490:1440 'button5 "" "TECH_S35D4" "tech.db" '("prBoundary" "boundary")) leSetAllLayerSelectable(t) leSetAllLayerVisible(t)

leSetLayerValid('("prBoundary" "boundary") t);<=  ?
leIsLayerValid('("prBoundary" "boundary") techGetTechFile(geGetEditCellView()))



term=css()~>instTerms
car(term)~>inst~>??

# sums all the numbers a kind of mathematica apply@@plus
(apply '+ '(
14899.46
16404.75
5999.62
6.00
20.00
7032.93
)
)


hiGetCurrentWindow()->cellView->?
hiGetCurrentWindow()->cellView->fileName
;==> "/home/validmgr/ebecheto/Work/AMS_S35_cad6/T2K_V5/buf_quiescent_sim/schematic/sch.oa"
cmd=sprintf(nil "echo cd %s" hiGetCurrentWindow()->cellView->fileName) system( cmd)

;; Kox : KPP=58é¬éµA/Vé¬é≤  KPN=170é¬éµA/V

Koxp=58u
Koxn=170u
vthn=OP("/MP2","vth")
vthp=OP("/MN2","vth")
W=10u
L=0.35u
LambdaN=deriv(IDC("/MN2/D"))/(Koxn*W/L/2*(VAR("Vgs")-vthn)*(VAR("Vgs")-vthn))
LambdaP=deriv(IDC("/MP2/D"))/(Koxp*W/L/2*(VAR("Vgs")-vthp)*(VAR("Vgs")-vthp))

plot(LambdaP);==> ~ 50mV^-1
plot(LambdaN);==> ~ 5mV^-1

awvSimplePlotExpression( window( 36 ) "expr( x  1  logRg( 10k 10M 50 ) )" nil nil )

;; awvSimplePlotExpression( window( 31 ) "expr( x  1  linRg( -400 10k 10M 50 ) )" nil nil )
awvSimplePlotExpression( window( 36 ) "expr( x  20*log(1)  logRg( 10k 10M 50 ) )" nil nil );<== log(1)=0 donc pas besoin de tracer la ligne

awvSimplePlotExpression( window( 36 ) "expr( x sin( x ) linRg( 0 1.5 .5 ) )" nil nil )

awvSimplePlotExpression( window( 36 ) "expr( x 2.635-x/1e-6*exp( -x/1e-6 ) linRg( 0 3u 100n ) )" nil nil )
awvSimplePlotExpression( window( 36 ) "expr( x 1.65+x/1e-6*exp( -x/1e-6 ) linRg( 0 3u 100n ) )" nil nil )
awvSimplePlotExpression( window( 36 ) "expr( x 1.65+x/1e-6*exp( -x/1e-6 ) linRg( 0 3u 100n ) )" nil nil )
awvSimplePlotExpression( window( 36 ) "expr( x 2.636-(x-100n)/0.5u*VAR(\"Qin\")/250f*0.85*exp(-(x-100n)/.5u) linRg( 0 3u 100n ) )" nil nil )
awvSimplePlotExpression( window( 68 ) "expr( x 1.65+1/7.7*(x-100n)/1e-6*exp( -(x-100n)/1e-6 ) linRg( 0 3u 100n ) )" nil nil )

linRg( 0 1.5 .5 )
logRg( 10 10G 1 );=> (10.0 100.0 1k 10k 100k 1M 1e+07 1e+08 1e+09 1e+10)
logRg( 10 10G 50);=> (10 ..(50step)... 100 ..(50step)... 1k ...x... 1e+10)

w_current = awvGetCurrentWindow()
awvGetSubwindowList(w_current)
awvGetOnSubwindowList( w_current)

sub1Name=awvGetWaveNameList( w_current)
;; => sub1Name= '((42 43) ("/CASC_1YAYA" "/OUT_SH"))
awvSetCurrentSubwindow( w_current 2 )

awvSetWaveNameList(sub1Name)
awvGetUnusedEntityList( w_current)
awvGetDrawStatus( w_current)
awvGetDisplayMode( w_current) ;;=>"composite"
awvPlaceYMarker(w_current 5E-12)
M1=awvPlaceXMarker(w_current 159k)

awvPrintWaveform( ?output "./myOutputFile" VT("OUT_SH") ?from 0 ?to 4u ?step 100n ?format "engineering")

awvPrintWaveform( ?output "./OutputFile" VT("OUT_SH") ?format "engineering")

awvGetYAxisLabel(w_current  2 ?subwindow 1 ?computed t)
w_windowId=w_current
awvSetYAxisLabel( w_windowId 1 "Voltage" ?subwindow 2 )
awvSetXAxisLabel( w_windowId g_label)

cell="SIOWIRE_ESD"
libList=list("IOLIB_4M" "IOLIB_ANA_3B_4M" "IOLIB_ANA_4M")
while( !libList && not((dbOpenCellViewByType car(libList) cell "layout")) libList=cdr(libList) );end while depile la liste tant que ne trouve pas la cellule
when( libList printf("%L found in %L\n" cell car(libList)) );; quand la liste n'est pas vide


;; imprime toutes les donnes d'une courbe;; prints all the data of a curve, even parametric data
awvPrintWaveform( VDC("/ADC_OUT<0>") ?format "engineering")

awvGetSubwindowList(w_id=awvGetCurrentWindow())
awvGetWaveNameList(w_id=awvGetCurrentWindow())
w_id=awvGetCurrentWindow()
foreach(mapcar  subWin awvGetSubwindowList(w_id)
awvSetCurrentSubwindow( w_id subWin )
foreach( mapcar courbe cadr(awvGetWaveNameList( w_id))
rexCompile("/") file=sprintf(nil "./dat_%s" rexReplace(courbe "_" 1) )
rexCompile("(") file=sprintf(nil "%s" rexReplace(file "_" 1) )
rexCompile(")") file=sprintf(nil "%s" rexReplace(file "_" 1) )
awvPrintWaveform( ?output file VT(courbe) ?format "engineering")
cmd=sprintf(nil "cat %s|sed \"s/time/\\#time/\" > %s.txt" file file)
cmd=sprintf(nil "%s\n rm %s" cmd file)
cmd=sprintf(nil "%s\n echo \"plot '%s.txt'  \" > %s.gp" cmd file file)
cmd=sprintf(nil "%s\n echo \"gnuplot %s.gp -persist\"" cmd file )
;; cmd=sprintf(nil "%s\n wc -l %s.txt|  1 " cmd file)
(system cmd)
))

dbCreateProp(css() "gnd" "netSet" "GND")
dbGetPropByName(css() "gnd")
css()~>prop

dbCreateProp(css() "vsub" "netSet" "VSS")
dbCreateProp(css() "gnd" "netSet" "VSS")
dbCreateProp(css() "vdd" "netSet" "VDD")

AGND3ALLP_3B :
dbCreateProp(css() "vsub" "netSet" "VSUB")
dbCreateProp(css() "gnd3o" "netSet" "VSS")
dbCreateProp(css() "gnd3r" "netSet" "VSS")
dbCreateProp(css() "vdd3o" "netSet" "VDD")

APRIOP_3B :
dbCreateProp(css() "vsub" "netSet" "VSUB")
dbCreateProp(css() "vdd3r" "netSet" "VDD")
dbCreateProp(css() "vdd3o" "netSet" "VDD")

AVDD3ALLP_3B :
dbCreateProp(css() "vsub" "netSet" "VSUB")
dbCreateProp(css() "gnd3o" "netSet" "VSS")
dbCreateProp(css() "vdd3r" "netSet" "VDD")
dbCreateProp(css() "vdd3o" "netSet" "VDD")

AVSUBP_3B :
dbCreateProp(css() "gnd3o" "netSet" "VSS")
dbCreateProp(css() "vdd3o" "netSet" "VDD"); IO~>prop~>name ;=> ("vdd3o")


cv = geGetWindowCellView()  ; IO~>prop~>?? ;=>...
foreach(IO setof(cell  cdr(cv~>instances)  cell~>cellName=="APRIOP_3B")
printf("%L " IO~>baseName)
dbCreateProp(IO "vsub" "netSet" "VSUB")
dbCreateProp(IO "vdd3r" "netSet" "VDD")
dbCreateProp(IO "vdd3o" "netSet" "VDD")
)

cv = geGetWindowCellView()
foreach(IO setof(cell  cdr(cv~>instances)  cell~>cellName=="AVSUBP_3B")
printf("%L " IO~>baseName)
)
dbCreateProp(IO "gnd3o" "netSet" "VSS")
dbCreateProp(IO "vdd3o" "netSet" "VDD")

foreach(IO setof(cell  cdr(cv~>instances)  cell~>cellName=="AVDD3ALLP_3B")
printf("%L " IO~>baseName)
dbCreateProp(IO "vsub" "netSet" "VSUB")
dbCreateProp(IO "gnd3o" "netSet" "VSS")
dbCreateProp(IO "vdd3r" "netSet" "VDD")
dbCreateProp(IO "vdd3o" "netSet" "VDD")
)

foreach(IO setof(cell  cdr(cv~>instances)  cell~>cellName=="AGND3ALLP_3B")
printf("%L " IO~>baseName)
dbCreateProp(IO "vsub" "netSet" "VSUB")
dbCreateProp(IO "gnd3o" "netSet" "VSS")
dbCreateProp(IO "gnd3r" "netSet" "VSS")
dbCreateProp(IO "vdd3o" "netSet" "VDD")
)


data="0001 1001"
split=parseString( data "") ;==> ("0" "0" "0" "1" " " "1" "0" "0" "1")
A=remove(" " split)
i=0 foreach(bit A i++ if(bit=="1" then printf("Bit %d is up\n" i)))


procedure(creatPWL_wave()
; si tdelay=200, t0=220 => debut trame a t0+delay=420
t0=230n; temps de depart. en simu, rajouter t_delay
dt=t0 ;<=delta time
chip="1000 0011"
register="0000 0001"
data="0001 1101"
oldbit="0" i=0
rexCompile(" ") name=rexReplace(data "_" 1)
printf("V_%s (net_%s 0) vsource dc=3.3 type=pwl delay=t_delay wave=[ \\\n"
name name)
foreach(bit remove(" " parseString( chip ""))
;; printf("BIt %d is up_Oldbit=%s\n" i oldbit)
if( bit=="1" then when(oldbit=="0" printf("%g d %g h\\\n" dt dt+1n))
else              when(oldbit=="1" printf("%g h %g d\\\n" dt dt+1n ))
)
dt=dt+40n
oldbit=bit)

;; Write bit+ack du chip adresse
when(oldbit=="1" printf("%g h %g d\\\n" dt dt+1n));<=write bit
dt=dt+40n
printf("%g h\\\n" dt);<=ack
dt=dt+40n oldbit="1"
foreach(bit remove(" " parseString( register ""))
if( bit=="1" then when(oldbit=="0" printf("%g d %g h\\\n" dt dt+1n))
else              when(oldbit=="1" printf("%g h %g d\\\n" dt dt+1n ))
)
dt=dt+40n
oldbit=bit)
;; acknowledge du registre
when(oldbit=="0" printf("%g d %g h\\\n" dt dt+1n)) dt=dt+40n oldbit="1"
;; write data
foreach(bit remove(" " parseString( data ""))
if( bit=="1" then when(oldbit=="0" printf("%g d %g h\\\n" dt dt+1n))
else              when(oldbit=="1" printf("%g h %g d\\\n" dt dt+1n ))
)
dt=dt+40n
oldbit=bit)
;; acknowledge du registre + stop
when(oldbit=="0" printf("%g d %g h\\\n" dt dt+1n)) dt=dt+40n
printf("%g h %g d\\\n" dt dt+1n);stop bit
printf("]\n")
); fin proc

Question : est-ce que la variable : $AMS_CURR_DIR est utilisable avec tous les design kit ou seulement AMS ?
getShellEnvVar("AMS_CURR_DIR")

foreach(mapcar inst cv~>instances
when(inst~>libName=="PRIMLIB"
when(inst~>cellName=="pmos4"
printf("___ Changing Instance %L ___\n" inst~>name)
foreach(mapcar prop inst~>prop
printf("PROP: %L %L %L %L\n" prop~>name prop~>value prop~>object prop~>objType)
when(prop~>name=="wtot"
inst~>libName="cmrf8sf"
inst~>cellName="pfet"
)
);enf foreach prop
);end when-mos
);end when-lib
when(inst~>cellName=="pmos4"
printf("<<< Changing TO Instance %L >>>\n" inst~>name)
printf("PROP:  %L %L\n" inst~>prop~>name inst~>prop~>value )
);end when newType
);end foreach


(cellView objType prop enum name object range value valueType assocTextDisplays)
phaseDegUnwrapped(getData("loopGain" ?result "stb"))
db(mag(getData("loopGain" ?result "stb")))

plot(value(db(mag(getData("loopGain" ?result "stb"))) cross(phaseDegUnwrapped(getData("loopGain" ?result "stb")),-180,1,"either") ))

plot(value(db(mag(getData("loopGain" ?result "stb"))) cross(phaseDegUnwrapped(getData("loopGain" ?result "stb")),-135,1,"either") ))

cross(phaseDegUnwrapped(getData("loopGain" ?result "stb")),-135,1,"either")
cross(phaseDegUnwrapped(getData("loopGain" ?result "stb")),-180,1,"either")


flip='(("INV0" "INVERT_A")("INV1" "INVERT_B")("INV2" "INVERT_C")("INV3" "INVERT_D")("INV4" "INVERT_E")("INV6" "INVERT_F")("INV8" "INVERT_H")("INV10" "INVERT_I")("INV12" "INVERT_J")("INV15" "INVERT_K"))

setof( newProp  flip  car(flip) == "INV1"||"INV1_3B" )modif 10 percent for the pass/fail color yellow
envSetVal("adexl.setupdb" "percentageForNearSpec" 'int 5)
examples in cadence of é√Émixed signal schenatic
ls -alF $CDSHOME/tools/dfII/samples/artist/mixSig/


car(css()~>instTerms~>net)~>??
(db:0x0fa0d33f cellView db:0x0fa0ef12 objType "net"
    prop nil allInstTerms
    (db:0x0fa0d1b8 db:0x0fa0d1a7 db:0x0fa0d19e db:0x0fa0d1b0) connStatus
    nil criticality 0 figs
    (db:0x0fa0f05f db:0x0fa0f05a db:0x0fa0f058 db:0x0fa0f05b db:0x0fa0f062
        db:0x0fa0f064 db:0x0fa0f06d
    )
    routePattern "steiner" groupMembers nil instTerms
    (db:0x0fa0d1b8 db:0x0fa0d1a7 db:0x0fa0d19e db:0x0fa0d1b0) name "net29" numBits 1
    parent nil pins nil shieldNet1
    nil shieldNet2 nil signals
    (db:0x0fa0d33f)
    sigNames
    ("net29") subnet nil subnets
    nil term nil terms nil
    textDisplays nil assocTextDisplays nil instTermCount
    4 markers nil routes nil
    source "netlist" aliases
    ("net29") isGlobal
    nil memInstTerms
    ((db:0x0fa0d1b8 0)
        (db:0x0fa0d1a7 0)
        (db:0x0fa0d19e 0)
        (db:0x0fa0d1b0 0)
    ) memNets
    ((db:0x0fa0d33f 0))
    memTerms nil sigType "signal"
)

wire=schCreateWire( cv "draw" "direct" list(4:1 6:3) 0.0625 0.0625 0.0125 ); <== creat wire line

car(css()~>instTerms~>net)~>figs~>??

css()~>conns~>term~>pins~>figs~>??

css()~>points ((10.0625 0.3125) (10.25 0.3125))
css()~>points=((10.0625 0.3125) (10.25 0.6125));<== ok, modifie les points d'un net

css()~>??
inst=css()
inst~>conns~>term~>pins~>figs~>??

;; ok pour cmrf8sf, pas ok pour cmhv7sf term<->inst
foreach( conn inst~>conns
tran=conn~>inst~>transform
rot=cadr(tran)
origin=car(tran)
printf("%s" conn~>term~>name)
foreach( fig conn~>term~>pins~>figs point=centerBox(car(fig~>bBox))
printf("@%L\n" dbTransformPoint( point list(origin rot) ))
))


;; ok pour cmrf8sf, pas ok pour cmhv7sf car il ne connait pas les 'term' d'un symbol qui n'existe pas => inclure DEFINE lib in cds.lib of old techno
foreach( conn inst~>conns
tran=conn~>inst~>transform
printf("%s" conn~>inst~>name)
foreach( fig conn~>inst~>pins~>figs point=centerBox(car(fig~>bBox))
printf("@%L\n" dbTransformPoint( point tran ))
))


dbTransformPoint( (1.5:2.5) list(0:0 "R90") )


dbTransformPoint( point list(origin rot) )
cv= geGetWindowCellView()
cv~>nets~>figs~>points~>??

i=0
foreach(mapcar net cv~>nets
foreach(mapcar point net~>figs~>points
i++
when(point==unPoint printf("Warning : %s cross %s at %L \n" net~>name "autrePoint" point))
)) printf("%d Points\n" i)

i=0
foreach(mapcar net cv~>nets
foreach(mapcar fig net~>figs
foreach(mapcar point fig~>points
i++
when(point==unPoint&&net~>name!="in_pa" printf("Warning : %s cross %s at %L\n" net~>name "autrePoint" point))
))) printf("%d Points\n" i)


unPoint='(-1.4375 0.5)
unPoint='(1.0625 -1.4375))
autrePoint='((1.0625 -1.4375)(0.5 -1.4375))
unPoint==autrePoint
difPoint=dbTransformBBox(autrePoint  list(0:1 "R0"))
unPoint==difPoint

foreach(mapcar point cv~>nets~>figs~>point~>?? printf("%L\n" point))


TODO
aRes=css()
aMos=css()
aMos~>instTerms
schSingleSelectPt() schSetEnv("sideways" t) mouseAddPt()

pinList='("G" "D" "S" "B")
pList = foreach( mapcar x pinList if(!listp(x) list(x x) x)) ;; pour les elements seul, "G", rajoute '("G" "G")

pinList='(("MINUS" "D") ("PLUS" "S") ("REF" "G"))
pList = foreach( mapcar x pinList if(!listp(x) list(x x) x )) ;; pour les elements seul, "G", rajoute '("G" "G")




foreach(mapcar term pList
aa = car(setof(x  aMos~>instTerms x~>name == term))
printf("Got %L\n" aa~>??)
printf("Got %L\t" caaar(aa~>term~>pins~>figs~>bBox))
printf("AbsolutePosition=%L\n" dbTransformPoint(centerBox(caar(aa~>term~>pins~>figs~>bBox)) aMos~>transform) )
)

;; dbTransformPoint( centerBox(car(aa)~>term~>pins~>figs~>bBox) list(aMos~>xy cadr(aMos~>transform)) )

schStretch( css() list(css()~>xy "MY")  ); shift move => moves also wires
dbMoveFig(css() nil list(css()~>xy "MY"))
css~>transform=dbTransformBBox(css()~>bBox  list(0:0 "MX"))
tr=dbConcatTransform(css()~>transform list(0:0 "MY"))
dbMoveFig(0:0 nil tr)

dbMoveFig(css() nil list(list(caadr(css()~>bBox)-caar(css()~>bBox) 0) "R0"))
dbMoveFig(css() nil list(list(caadr(css()~>bBox)-caar(css()~>bBox) 0) "R0"))
dbMoveFig(css() nil list(list(caadr(css()~>bBox)-caar(css()~>bBox) 0) "R0"))
println(css()~>bBox);=> ((0.31875 0.5375) (0.86875 2.13125))
;; 0.86875-0.31875 = 0.55
list(caadr(css()~>bBox)-caar(css()~>bBox)) ;=> 0.55

;; should be after move plus rot (0.40625 1.125) => (1.15625 1.125) => 0.75

;; Pour flipper/sideways une rpoly si en MYR90 -> 0.18125 offest par rapport a la bBox

dbMoveFig(css() nil list(list(caadr(css()~>bBox)-caar(css()~>bBox)-0.18125 0) "R0")) css()~>orient="R270"



inst=css()


procedure(rpolySideWays(@optional (inst css()))
let((sideWay horiz vert toRotate)
sideWay='(("R0" "MY")("R90" "MX90")("R180" "MX")("R270" "MYR90"))
sideWay=append(sideWay foreach(mapcar x sideWay list(cadr(x) car(x)))); and the way around
horiz='("R90" "MX90" "R270" "MYR90")
vert ='("R0"  "MY"   "R180" "MX"   )
if(member(inst~>orient horiz) then
foreach(mapcar rot sideWay
when(inst~>orient==car(rot) toRotate=rot));when foreach passage rotation
printf("sideway %s into %L\n" inst~>orient toRotate)
dbMoveFig(inst nil list(list(caadr(inst~>bBox)-caar(inst~>bBox)-0.1875 0) "R0")) inst~>orient=cadr(toRotate)
else
printf("Vertical entre PLUS et MINUS\n")
)
));let proc

css()~>instTerms~>term~>pins~>figs~>??


foreach( conn css()~>conns
when("PLUS"==conn~>term~>name
foreach( fig conn~>term~>pins~>figs point=centerBox(car(fig~>bBox)))
)) printf("Get %L \n" point)

foreach( conn css()~>conns
when("MINUS"==conn~>term~>name
foreach( fig conn~>term~>pins~>figs point=centerBox(car(fig~>bBox)))
)) printf("Get %L \n" point)

procedure(getTermPoint(@optional (inst css()) (NAME "PLUS") )
let((point) foreach( conn inst~>conns when(NAME==conn~>term~>name
point=centerBox(caar(conn~>term~>pins~>figs)~>bBox);<= OK car une seul pin "PLUS" dans le symbol(figs)
)) point ));let proc

dx=cadr(getTermPoint(css() "PLUS"))-cadr(getTermPoint(css() "MINUS"))


procedure(rpolySideWays(@optional (inst css())(term1 "PLUS")(term2 "MINUS"))
let((sideWay horiz vert toRotate dx hv)
dx=cadr(getTermPoint(inst term1))-cadr(getTermPoint(inst term2))
sideWay='(("R0" "MY")("R90" "MXR90")("R180" "MX")("R270" "MYR90"))
sideWay=append(sideWay foreach(mapcar x sideWay list(cadr(x) car(x)))); and the way around
horiz='("R90" "MXR90" "R270" "MYR90") hv="vertical"
vert ='("R0"  "MY"    "R180" "MX"   )
when(inst~>orient=="R270"||inst~>orient=="MXR90" dx=-dx)
foreach(mapcar rot sideWay
when(inst~>orient==car(rot) toRotate=rot));when foreach passage rotation
when(member(inst~>orient horiz)
hv="horizontal"
dbMoveFig(inst nil list(dx:0 "R0"))
); vert ou horiz
inst~>orient=cadr(toRotate)
printf("sideway %s between %s-%s %s into %s\n" hv term1 term2 car(toRotate) cadr(toRotate) )
));let proc

rpolySideWays(css() "S" "D") ;<== pour oprppres, pas besoin de dbMove car l'origin est au centre de la cellule et non sur PLUS


css()~>conns~>term~>pins~>??

pfet
centerBox(css()~>bBox);=>(7.71875 -0.26875)
css()~>xy;=>		 (7.59375 -0.28125)

nmos
centerBox(css()~>bBox);=>(7.384375 -0.09375)
css()~>xy;=>		 (7.59375 -0.28125)

getTermPoint(css() "S")   ;=>(0.0 -0.1875)
getTermFig(css() "PLUS");=>(0.0 0.0)

toMove=rodSubPoints( '(0.0 0.0)  '(0.0 -0.1875))
dbMoveFig(css() nil list(toMove "R0"))
dbMoveFig(inst nil list(toMove "R0"))

ligne crossing point
pcColinearPoints('(4.75 -0.78125) '(5.875 -0.78125) '(5.875 -0.78125))


getTermPoint(css() "S");=> (0.25 -0.1875)
rodAddPoints(css()~>xy getTermPoint(css() "S"));=>> (5.875 -1.15625) ;<== not good
rodAddPoints(css()~>xy getTermPoint(css() "D"));=>> (5.875 -0.78125) ;<== yes! good
dbTransformPoint(getTermPoint(css() "S") css()~>transform);<== tjrs pas..,SI Si si mais je me suis trompe de pin :D
dbTransformPoint(css()~>xy   list(getTermPoint(css() "S") css()~>orient))

dbTransformPoint(getTermPoint(css() "MINUS") css()~>transform)

pcColinearPoints( l_pointList1 l_pointList2 l_pointList3 )

foreach(mapcar net cv~>nets
foreach(mapcar fig net~>figs
when(pcColinearPoints(car(fig~>points) cadr(fig~>points) '(5.875 -0.78125)) fig~>lpp='("wire" "flight"))))

aa=dbOpenCellViewByType("cmrf8sf" "oprppres" "symbol")
aa~>signals~>terms~>pins~>fig~>??

procedure(getMasterTermPoint(@optional (master css()) (NAME "PLUS") )
let((point)
when(master~>objType=="inst" master=css()~>master)
foreach( conn master~>terminals when(NAME==conn~>name
point=centerBox(caar(conn~>pins~>figs)~>bBox);<= OK car une seul pin "PLUS" dans le symbol(figs)
)) point ));let proc

procedure(getAllMasterTermPoint(@optional (master css()) )
let((points) points='()
when(master~>objType=="inst" master=css()~>master)
foreach( conn master~>terminals
points=tconc(points list(conn~>name centerBox(caar(conn~>pins~>figs)~>bBox)));<= OK car une seul pin "PLUS" dans le symbol(figs)
) car(points) ));let proc

procedure(getAllMasterTermName(@optional (master css()) )
let((points) points='()
when(master~>objType=="inst" master=css()~>master)
foreach( conn master~>terminals
points=tconc(points list(conn~>name centerBox(caar(conn~>pins~>figs)~>bBox)));<= OK car une seul pin "PLUS" dans le symbol(figs)
) car(points) ));let proc


css()~>master~>terminals~>name

A=dbOpenCellViewByType("cmrf8sf" "nfet" "symbol")
B=dbOpenCellViewByType("PRIMLIB" "nmos4" "symbol")
A~>terminals~>name
B~>terminals~>name
sA=sort(A~>terminals~>name nil)
sB=sort(B~>terminals~>name nil)
A==B
sA==sB

inst=css();nmos4
inst~>xy

absVals=nil foreach(NAME sA
absVals=tconc(absVals list(NAME rodAddPoints(inst~>xy getMasterTermPoint(A NAME))))
) car(absVals)

absVals=nil foreach(NAME sB
absVals=tconc(absVals list(NAME rodAddPoints(inst~>xy getMasterTermPoint(B NAME))))
) car(absVals)


dftNewLib="cmos8rf"
flip='(("INV0" "INVERT_A")("INV1" "INVERT_B"))
concFlip='()
foreach(fp flip
when(length(fp)==1 fp=append(fp list(fp)))
when(length(fp)==2 fp=append(fp list(dftNewLib)))
concFlip=tconc(concFlip fp)
) car(concFlip);=> ("INV0" "INVERT_A" "cmos8rf") ("INV1" "INVERT_B" "cmos8rf")


dftNewLib="cmrf8sf" concFlip='()
flip='("subc" ("nmos4" "nfet") ("pmos4" "pfet")("rpolyhc" "oprppres")("rpolyh" "oprppres")("rpoly2c" "oprppres")("rpoly2" "oprppres")("cpoly" "mimcap"))
flip=append(flip '(("INV0" "INVERT_A" "cmos8rf") ("INV1" "INVERT_B" "cmos8rf")))
foreach(fp flip
when(!listp(fp) fp=list(fp))
when(length(fp)==1 fp=append(fp fp))
when(length(fp)==2 fp=append(fp list(dftNewLib)))
concFlip=tconc(concFlip fp)
) car(concFlip)


;cadddr('("pmos4" "pfet" "cmrf8sf" ("flipProp" (("w" "wf") ("wtot" "wt") ("ng" "nf")))))
;nth(3 '("pmos4" "pfet" "cmrf8sf" ("flipProp" (("w" "wf") ("wtot" "wt") ("ng" "nf")))))


netName="GND"  cv=geGetWindowCellView()
foreach( net cv~>nets
foreach( fig net~>figs
foreach( point fig~>points
when(net~>name==netName||net~>name==strcat(netName "!")
printf("%s line %L\n" net~>name  point))
)))


procedure(changeInstMovePoint(@optional   (newName "nfet") (newLib "cmrf8sf") (inst css()) (cv geGetWindowCellView())  )
let((sA sB flipPin Axy)
;; A=old B=new
Axy=inst~>xy
A=dbOpenCellViewByType(inst~>libName inst~>cellName "symbol")
B=dbOpenCellViewByType(       newLib        newName "symbol")
; #### move nets of pins location modification
sA=sort(A~>terminals~>name nil)
sB=sort(B~>terminals~>name nil)
when(sA==sB flipPin=foreach(mapcar x sA append(flipPin list(x x))))
when(flipPin
printf("FLIPPING  %L TOFLIP \n" flipPin)
foreach(pAB flipPin
pA=car(pAB); ie. pin name "S"
pB=cadr(pAB)
mvB=rodAddPoints(Axy getMasterTermPoint(B pB))
mvA=rodAddPoints(Axy getMasterTermPoint(A pA))
netName=getInstNetName(inst pA) ;get net name connected to inst "S" ie. => "net079"
printf("TOMOVE:%L %s %L %L\n" pAB netName mvA mvB)
when(mvA!=mvB
printf("different points: %L %L %L\n" netName mvA mvB)
foreach( net cv~>nets
when(net~>name==netName||net~>name==strcat(netName "!")
printf("catch net: %L \n" netName)
isBetweenPoints(mvB netName cv); change to 'flight lines' a possible crossing net when netNames are differents
foreach( fig net~>figs
mvPoints=foreach(mapcar point fig~>points if(point==mvA then mvB else point)); check wheter point1 or point2 is to move
;and change only if a point match the pin location mA
printf("%L!=?FIG: \n%L \t\t\tA:%L B:%L\n" fig~>points  mvPoints mvA mvB)
when(fig~>points!=mvPoints fig~>points=mvPoints ;if a point had been changed it has to move
printf("\n** changing %L %s form %L to %L\n" fig netName fig~>points mvPoints)
);when different points
);move old point A to new point B
); catch netName to move
);end check all nets
); postions pins are different mvA!=mvB
);end check all pins pAB to flip off selected instance   0x0fb18393
); when flipPin list is not nil
));end let proc

;; ((1.5 -0.6875)   (1.59375 -0.6875)

inst=css()
schStretch(list(inst) list(rodSubPoints(aPoint bPoint) "R0"));<== moves with wires

schStretch(list(inst) list(rodSubPoints(dbTransformPoint(rodAddPoints('(-0.0625 0.0)  inst~>xy) list('(0.0 0.0) inst~>orient inst~>mag )) inst~>xy ) "R0"))


schStretch(list(inst) list('(0 0) "R0" ));<== ne fait rien
schStretch(list(inst) list('(0 0) "R90" ));<== ne fait rien
schStretch(list(inst) list(inst~>xy "R0" ));<== deplace de xy
schStretch(list(inst) list(inst~>xy "R90" ));<== deplace de xy et tourne de 90 /origin
css()~>orient="R270"
css()~>orient="MXR90"


** changing db:0x105ee633 S form ((5.375 -0.78125) (5.4375 0.03125)) to ((5.375 -0.78125) (5.4375 0.03125))
** changing db:0x105ee633 S form ((5.4375 -0.84375) (5.4375 0.03125)) to ((5.375 -0.78125) (5.4375 0.03125))

isBetweenPoints(mvB netName cv)
isBetweenPoints('(5.4375 -0.84375) "net079")


dbTransformPoint('(-0.0625 0) css()~>transform)
css()~>xy




;; schStrech need to change origin from the following trick, (from documentation)
xy=css()~>xy
newPoint=rodSubPoints(css()~>xy dbTransformPoint('(-0.0625 0) css()~>transform))
xform=list(newPoint "R0" 1)
newXform=dbConcatTransform(
dbConcatTransform(
list(mapcar('minus xy) "R0" 1) xform)
list(xy "R0" 1))
; And then do:
schStretch(list(css()) newXform)

adjust='(-0.0625 0)
xform=list(rodSubPoints(inst~>xy dbTransformPoint(adjust inst~>transform)) "R0" 1)
schStretch(list(inst) dbConcatTransform(dbConcatTransform(list(mapcar('minus inst~>xy) "R0" 1) xform) list(inst~>xy "R0" 1)))

l1='("A" "B" "Q") l2='("B" "A" "Z")
foreach(mapcar x l1 when(member(x l2) x)) ;==> ("A" "B" nil) ;; PB comment enlever nil : ANSWER : remove(nil '("A" "B" nil)) ;=>("A" "B")
tmp='()
foreach( x l1 when(member(x l2) tmp=tconc(tmp x))) tmp=car(tmp)



tmp='()
foreach( x sA when(member(x sB) tmp=tconc(tmp x))) tmp=car(tmp);==> get similar names
foreach( x tmp when(not(apply('or foreach(mapcar z flipPin cadr(z)==x))) flipPin=append(flipPin list(list(x x)) )))
;append only if samePin not present in second member of flipPin


; tmp='("A" "B")
; flipPin='(("PLUS" "D")("A" "TATA")("MINUS" "S"))
tmp2=t
foreach( p flipPin foreach( x tmp when(car(p)==x tmp2=t)))
when(tmp2 foreach(samePin tmp flipPin=append(flipPin list(list(samePin samePin)))))

aa=foreach(mapcar x tmp foreach(mapcar p flipPin printf("cadr(%L)?=%L:%L\n" p x  list(cadr(p)==x)) cadr(p)==x));==> ((nil t nil) (nil nil nil))
foreach(mapcar z aa apply('or z)) ;==> (t nil)

foreach(z aa if(apply('or z) printf("GO: or(%L)\n" z) printf("NON\n")))


tata=car(setof(g_lib  ddGetLibList() g_lib~>name=="IOLIB_4M"))
tata=car(setof(g_lib  ddGetLibList() g_lib~>name=="IOLtatata"));==> Permits to check existance of a library exit lib dd:0xfafaa or nil


procedure(firstExistCell(cell  @optional (libList ddGetLibList()) )
let((g_libList ret)
if(type(car(libList))=='string then printf("String\n")
g_libList=foreach(mapcar lib libList
when(member(lib ddGetLibList()~>name) 
printf("g_lib~>name=%L\n" lib~>name)
car(setof(g_lib  ddGetLibList() g_lib~>name==lib))) else printf("NOT String\n")
g_libList=libList
)
foreach( g_lib g_libList
printf("%L %L %L\n" g_lib g_lib~>name cell)
when(member("layout" dbAllCellViews(g_lib cell))  ret=g_lib~>name ) )
ret
))
firstExistCell("AVSUBP_3B")

firstExistCell("AVSUBP_3B" '("IOLIB_ANA_3B_4M" "IOLIB_3B_4M" "IOLIB_ANA_4M"))


cv=geGetWindowCellView()
cv~>instances~>master~>shapes~>??
cv~>instances~>master~>shapes~>lpp
cv~>instances~>master~>shapes~>layerName

setof(shape cv~>instances~>master~>shapes shape~>layerName=="PAD")



foreach(inst cv~>instances
foreach(obj inst~>master~>shapes
X1=caadr(obj~>bBox) X0=caar(obj~>bBox)
printf("%L %L %L %L \n"  obj X1-X0 obj~>bBox obj~>layerName)
))




procedure(getMaxXsizeLayer(@optional (layer "MET1") (cv geGetWindowCellView()))
let((max) max=0
car(foreach(mapcar inst cv~>instances foreach(obj inst~>master~>shapes
when(obj~>layerName==layer&&(dX=caadr(obj~>bBox)-caar(obj~>bBox))>max max=dX)
) max))))

bBox='((2.5 0.0) (97.5 95.0))
(dX=caadr(bBox)-caar(bBox))>max

procedure(getMaxXsizeLayer(@optional (layer "MET1") (cv geGetWindowCellView()))
let((max min) max=0 min=0
foreach(obj cv~>shapes
when(obj~>layerName==layer&&(dX=caadr(obj~>bBox))>max max=dX)
when(obj~>layerName==layer&&(dX=caar(obj~>bBox))<min min=dX)
) list(min max)))



aa=(dbOpenCellViewByType "IOLIB_ANA_4M" "APRIOP" "layout")
getMaxXsizeLayer("MET1" aa)
aa=(dbOpenCellViewByType "IOLIB_4M" "CORNERP" "layout")
getMaxXsizeLayer("MET1" aa)



inst=css()
dbTransformPoint(inst~>xy inst~>transform)




cv=geGetWindowCellView()
depth=0 sList='() layer="MET1" xy='(0 0) transform='((0 0) "R0" 1)
;while()
mast=cv
when(
obj=foreach(mapcar s mast~>shapes when(s~>layerName==layer list(s s~>bBox)))
sList=append(sList list( depth transform  obj))
)
foreach(inst mast~>instances
depth++
printf("%L %L"  inst~>cellName inst~>transform)
transform=inst~>transform
master=inst~>master
when(obj=foreach(mapcar s master~>shapes when(s~>layerName==layer list(s s~>bBox)))
;;bBox=dbTransformBBox(s~>bBox transform)
sList=append(sList list( depth transform  obj)))
)


cv=geGetWindowCellView()
depth=0 sList='() layer="MET1" xy='(0 0) transform='((0 0) "R0" 1)
;while()
mast=cv
when(
obj=foreach(mapcar s mast~>shapes when(s~>layerName==layer list(s dbTransformBBox(s~>bBox transform))))
sList=append(sList list( depth transform  obj))
)
foreach(mapcar inst mast~>instances
depth++
printf("%L %L"  inst~>cellName inst~>transform)
transform=inst~>transform
master=inst~>master
when(obj=foreach(mapcar s master~>shapes when(s~>layerName==layer list(s dbTransformBBox(s~>bBox transform))))
printf("%L\n" obj)
sList=append(sList list( depth  obj)))
)


cv=geGetWindowCellView()
depth=0 sList='() layer="MET1" xy='(0 0) transform='((0 0) "R0" 1)
printf("Absolute position of Hierarchy bBox shapes %L %L\n" cv~>cellName layer)
master=cv
while(foreach(mapcar instance master~>instances
depth++
foreach(mapcar inst instance~>master~>instances
printf("%L %L"  inst~>cellName inst~>transform)
transform=inst~>transform
master=inst~>master
when(obj=foreach(mapcar s master~>shapes when(s~>layerName==layer s~>bBox))
printf("%L\n" obj)
sList=tconc(sList list(transform obj))
))
master=inst~>master
)
printf("%n" depth)
)

;___________________
depth=0 sList='() layer="MET1" xy='(0 0) transform='((0 0) "R0" 1)
printf("Absolute position of Hierarchy bBox shapes %L %L\n" cv~>cellName layer)
master=cv

when(obj=foreach(mapcar s master~>shapes when(s~>layerName==layer s~>bBox))
printf("%L\n" obj)
sList=tconc(sList list(transform obj))
)

transform=car(master~>instances)~>transform
master=car(master~>instances)~>master

when(obj=foreach(mapcar s master~>shapes when(s~>layerName==layer s~>bBox))
printf("%L\n" obj)
sList=tconc(sList list(transform obj))
)

;_____________________________________


depth=0 sList='() layer="MET1" xy='(0 0) transform='((0 0) "R0" 1)
printf("Absolute position of Hierarchy bBox shapes %L %L\n" cv~>cellName layer)
master=cv

when(obj=foreach(mapcar s master~>shapes when(s~>layerName==layer s~>bBox))
printf("%L\n" obj) sList=tconc(sList list(transform obj)))

foreach(mapcar inst master~>instances
master=inst~>master
transform=inst~>transform
when(obj=foreach(mapcar s master~>shapes when(s~>layerName==layer s~>bBox))
printf("%L\n" obj) sList=tconc(sList list(transform obj)) );end when instance has shapes

;master=car(master~>instances)~>master;<== done by foeerach loop
)



;_____________________________________
depth=0 sList='() toTrans='() layer="MET1" xy='(0 0) transform='((0 0) "R0" 1)
printf("Absolute position of Hierarchy bBox shapes %L %L\n" cv~>cellName layer)
master=cv
toTrans=append(toTrans list(transform))
when(obj=foreach(mapcar s master~>shapes when(s~>layerName==layer s~>bBox))
absBBox=0
res=foreach(mapcar bBox obj foreach(mapcar tr reverse(toTrans)  bBox=dbTransformBBox(bBox tr)))
sList=tconc(sList res))

if(inst=master~>instances
then
foreach(mapcar inst master~>instances
master=inst~>master
transform=inst~>transform

toTrans=append(list(transform) toTrans)

)
else
toTrans=cdr(toTrans)
)


cv5=geGetWindowCellView()

master=cv5 i=0
while(master~>instances
foreach(mapcar instance master~>instances i++
printf("%L \n" list(i instance~>cellName instance~>baseName))
master=instance~>master
)
)


tata='(1 2 3 4 5)
foreach(mapcar instance tata tata=cdr(tata))


nodeList='() master=cv5
dy=length(master~>instances)
nl=append(nodeList list(list(dy master~>instances)));node list with 1st element : length of the elements =>useless
master~>transform
nl=append(nodeList list(list(dy master~>instances)));node list with 1st element : length of the elements =>useless
;; empile et depile node list

while(nl
;;inst=nth(caar(nl)-1 cadar(nl))
inst=caadar(nl)
printf("INST:%L. Depth:%d\n" list(inst~>name inst~>cellName) length(nl))
tail=cdr(nl)
chopHead=cdr(cadar(nl))
when(tail nl=append(list(length(chopHead) chopHead) list(tail)))
when(chopHead nl=list(list(length(chopHead) chopHead)))
when(!chopHead nl=nil)
)




foreach(mapcar inst master~>instances
master=foreach( master inst~>master printf("%L \n" list(master inst~>cellName inst~>baseName)) master)
))


foreach(mapcar x '(1 2 3 4 5) x*x);=>(1 4 9 16 25)
foreach( x '(1 2 3 4 5) x*x)	  ;=>(1 2 3 4 5)  



;; http://www.linuxselfhelp.com/gnu/emacs-lisp-intro/html_chapter/emacs-lisp-intro_8.html
(nthcdr 2 '(pine fir oak maple))                   ;=>(oak maple)
(setq animals '(giraffe antelope tiger lion))	   ;=>(giraffe antelope tiger lion)
(setcar animals 'hippopotamus)			   ;=>(hippopotamus antelope tiger lion)
(setq domesticatedAnimals '(horse cow sheep goat)) ;=> (horse cow sheep goat)
(setcdr domesticatedAnimals '(cat dog))		   ;=> (horse cat dog) 

;; http://www.delorie.com/gnu/docs/elisp-manual-21/elisp_83.html
(setq sampleList '(a b c a b c)); => (a b c a b c)
(remq 'a sampleList)            ; => (b c b c)
sampleList                      ; => (a b c a b c) ;The letter `q' in remq says that it uses eq to compare object against the elements of list.
;; The function delq offers a way to perform this operation destructively.

(setq sampleList '(a b c (4)));     => (a b c (4))  ; *Error* eval: undefined function - delq  <= pas de fonction dleq avec skill
(delq 'a sampleList) ;     => (b c (4))
sampleList           ;     => (a b c (4))
(delq 'c sampleList) ;     => (a b (4))
sampleList           ;     => (a b (4))

;(delete '(2) '((2) (1) (2))) ;     => ((1))
;(delete '(2) [(2) (1) (2)])  ;     => [(1)]
(remove '(2) '((2) (1) (2))) ;     => ((1))

assocList='( ("A" 1) ("B" 2) ("C" 3))   ;=> (("A" 1) ("B" 2) ("C" 3) ("A" 4))
assoc("A" assocList )                   ;=> ("A" 1)
assoc("B" assocList )                   ;=> ("B" 2)
assoc("D" assocList )                   ;=> nil
rplaca(cdr(assoc("B" assocList)) "two") ;=>  <=> setcdr in foreach loop
assocList                               ;=> (("A" 1) ("B" "two") ("C" 3))
;; PB with list with multiples equal car
;; mais les instances ont toutes des db: differents=> OK




nodeList='() master=cv5
dy=length(master~>instances)
nl=append(nodeList list(list(dy master~>instances)));node list with 1st element : length of the elements =>useless
master~>transform
nl=append(nodeList list(list(dy master~>instances)));node list with 1st element : length of the elements =>useless
;; empile et depile node list

while(master~>instances
;;inst=nth(caar(nl)-1 cadar(nl))
inst=caadar(nl)
printf("INST:%L. Depth:%d\n" list(inst~>name inst~>cellName) length(nl))
tail=cdr(nl)
chopHead=cdr(cadar(nl))
when(tail nl=append(list(length(chopHead) chopHead) list(tail)))
when(chopHead nl=list(list(length(chopHead) chopHead)))
when(!chopHead nl=nil)
)


instLevel=foreach(mapcar inst master~>instances inst~>master~>instances )
instLevel2=foreach(mapcar inst instLevel inst~>master~>instances )


apply('or instLevel)

instLevel='(nil (db:0x1005b512) (db:0x1005ad92))
mapcar( '(lambda (arg) (when arg t )) instLevel)            ;=> (nil t t)
apply('or mapcar( '(lambda (arg) (when arg t )) instLevel)) ;=> t



instLevel=foreach(mapcar inst master~>instances append(list(inst) list(inst~>master~>instances)))
instLevel2=foreach(mapcar inst instLevel append(list(inst) list(inst~>master~>instances )))
instLevel3=foreach(mapcar inst instLevel2 append(list(inst) list(inst~>master~>instances )))
instLevel4=foreach(mapcar inst instLevel3 printf("INSTLevel:%L\n" list(inst~>master~>instances ))  append(list(inst) list(inst~>master~>instances )))
checkLevel=foreach(mapcar inst instLevel3 printf("CHECKLevel:%L\n" list(inst~>master~>instances ))  append(list(inst) list(inst~>master~>instances )))

reverse(instLevel4~>master~>instances)

foreach(mapcar x instLevel2 nthcdr(2 instLevel2))

last(instLevel4)


depth=0
foreach(x instLevel4 depth++ x=car(x)) depth


instLevel=foreach(mapcar inst master~>instances append( list(inst~>master~>instances) list(inst)))
instLevel2=foreach(mapcar inst instLevel        append( list(inst~>master~>instances) list(inst)))
instLevel3=foreach(mapcar inst instLevel2       append( list(inst~>master~>instances) list(inst)))
instLevel4=foreach(mapcar inst instLevel3       append( list(inst~>master~>instances) list(inst)))
instLevel5=foreach(mapcar inst instLevel4       append( list(inst~>master~>instances) list(inst)))

foreach(mapcar x instLevel4 length(x))

depth=0
foreach(x car(instLevel4) depth++ x=car(x)) depth
foreach(x last(instLevel4) depth++ x=car(x)) depth
foreach(x last(instLevel5) depth++ x=car(x)) depth



depth=0
x=instLevel4
x=tail(instLevel4)
x=car(instLevel4)
while(type(x)=='list&&x!=nil depth++ printf("%d %L\n" depth x) x=car(x)) depth


list(length(instLevel) length(instLevel2) length(instLevel3) length(instLevel4))
list(length(car(instLevel)) length(car(instLevel2)) length(car(instLevel3)) length(car(instLevel4)))

levels=list(instLevel instLevel2 instLevel3 instLevel4)
mapcar('length levels)
mapcar('length (mapcar 'car levels))


depth=0 mapcar( '(lambda (arg) (while arg!=nil depth++ arg=car(arg))) instLevel3)            ;=> (nil t t)

depth=0 x=instLevel3
while(depth<10||(apply 'or x)
depth++ 
printf("DEPTH:%d %L\n" depth x)
x=foreach(mapcar arg x car(arg)))




master=geGetWindowCellView()
tree=master~>instances
level0=master~>instances

level1=foreach(mapcar inst level0 inst~>master~>instances)
level2=foreach(mapcar inst level1 inst~>master~>instances)
level3=foreach(mapcar inst level2 inst~>master~>instances)
level4=foreach(mapcar inst level3 inst~>master~>instances)


;; flatten fct thanks to http://answers.yahoo.com/question/index?qid=20101106203548AALDgwY

(defun flatten (list)
(cond
((null list) list)   ;=> nothing in the list anymore = stop condition
((null (car list)) (flatten (cdr list)))     ;=> first element is nil => ignore it and go further
((atom (car list)) (cons (car list) (flatten (cdr list))))  ; when first element is single process it (cons) and go further is returned
(t                 (append (flatten (car list)) (flatten (cdr list)))) ; else append head and tail with the function itself recursing
))


master=geGetWindowCellView()
tree=master~>instances
i=0
while(flatten(tree)
i++
printf("I=%d %L\n" i tree)
tree=foreach(mapcar inst tree inst~>master~>instances)
)


tree=master~>instances res='()
tree=master~>instances res=list(tree)
while(flatten(tree)
tree=foreach(mapcar inst tree inst~>master~>instances)
res=append(list(tree) res)
)



(defun flattenTrans (list)
(cond
((null list) list)
((null (car list)) (append '(nil) (flatten (cdr list))))
((atom (car list)) (cons list~>transform (flatten (cdr list))))
(t                 (append (flatten (car list)) (flatten (cdr list))))
)) flattenTrans(tree)

(atom list('x))  ;nil
(atom list(nil)) ;nil
(atom list(t))	 ;nil
(atom 'tata )	 ;t  
(atom 'x )	 ;t  
(atom 168 )	 ;t  
(atom '(   ) )	 ;t  
(atom nil )	 ;t  
(atom t )	 ;t  


(null list('x))  ;nil
(null list(nil)) ;nil
(null list(t))	 ;nil
(null 'tata )	 ;nil  
(null 'x )	 ;nil  
(null 168 )	 ;nil
(null '(   ) )	 ;t
(null nil )	 ;t  
(null t )	 ;t   ?!!! it does !
(null 't) ;=>!'t =>nil   
(null !t)  ;=> !!t   ;=> t
(null !nil);=> !!nil ;=> nil




help null; null( g_value ) => t | nil Checks if an object is equal to nil.
help not ; not( g_obj )    => t | nil Same as the ! operator. Returns t if the object is nil, and returns nil otherwise.
help atom; atom( g_arg )   => t | nil Checks if an object is an atom.


;; http://cera.us/ta/cs380_00f/lisp.examples.lsp
; word-count, counts all arguments, including embedded arguments
(defun wc (x)
  (cond ((null x) 0)
        ((atom x) 1)
        (t (+ (wc (car x))
              (wc (cdr x))))))
;USER(16): (wc '(a b c))
;3
;USER(17): (wc '(a b (c d) e))
;5
;------------------------------------------------------------------------------
; flattens all embedded lists
(defun flatten (x)
  (cond ((null x) nil)
        ((atom x) (list x))
        (t (append (flatten (car x))
                   (flatten (cdr x))))))

;USER(19): (flatten '(a b (c d) e))
;(A B C D E)



(defun listIntersection (l1 l2)
  (cond ((or (null l1) (null l2)) nil)
    ((member (car l1) l2)
    (cons (car l1)
    (listIntersection (cdr l1) l2)))
    (t (listIntersection (cdr l1) l2))))

listIntersection('('A 'B 'C 'N '('T 'N)) '('C 'D '('T 'N ) '('N) 'E))
;=> ('C '('T 'N))

; ------------------------------------------------------------------------------
(defun listDifference (l1 l2)
  (cond ((null l2) l1)
    ((null l1) nil)
    ((member (car l1) l2) 
    (listDifference (cdr l1) l2))
    (t (cons (car l1) (listDifference (cdr l1) l2)))))
listDifference('(A B C N (T N))        '(C D (T N ) (N) E)) ;=> (A B N)
listDifference( '(C D (T N ) (N) E)   '(A B C N (T N))    ) ;=> (D (N) E)
; ------------------------------------------------------------------------------
(setq alf  '(a b c d e f g h))
;# SIMULATED STACK POPPING, pops first element, and stores cdr into alf
(prog1 (car alf) (setq alf (cdr alf))) ;=> a ; but alf='(b c d e f g h)



(defun flatten (x)
  (cond ((null x) nil)
        ((atom x) (list x))
        (t (append (flatten (car x))
                   (flatten (cdr x))))))

(defun wc (x)
  (cond ((null x) 0)
        ((atom x) 1)
        (t (plus (wc (car x))
              (wc (cdr x))))))
wc('(R F E G (FF F ))) ;=> 6


(defun sum (x)
  (cond ((null x) 0)
        ((atom x) x)
        (t (plus (sum (car x))
              (sum (cdr x))))))

sum('(1 2 3 4 (5 6 ))) ;=> 21   == (7*6/2)

;; GENERAL RECURSION for tre/ AST parsing
(defun FCT (x)
(cond 
((null x) 0) ; <= STOP CONDITION, wheter nil or 0 or "" or t...
((atom x) x) ; <= what to do when there is only one element. Indeed, car(oneElement) => fail! so this case has to be treated
(t ( (FCT(car x)) (FCT (cdr x))))  ; <= do something with FCT(car(x)) and FCT(cdr(x))
))


master=geGetWindowCellView()
tree=master~>instances

(defun flattenTrans (x)
(cond
((null x) nil)
((null x) nil)
((atom x) printf("%L\n" list(x~>transform )) list(x~>transform ))
(t      printf("%L\n" list(x~>transform ))  (append (flattenTrans (car x)) (flattenTrans (cdr x))))
))
flattenTrans(tree)


(defun recInstance (x)
(cond
((null x) nil)
((atom x) printf("ATOM :%L\n" list(x~>baseName x~>cellName x~>master~>instances )) list(x~>master~>instances ))
(t      printf("MULT :%L\n" list(x~>baseName x~>cellName x~>master~>instances ))  
printf("CAR :%L\n" (car x))
printf("CDR :%L\n" (cdr x))
(append (recInstance (car x)) (recInstance (cdr x))))
))
recInstance(tree)


(defun scope (x)
(cond
((null x) "")
((atom x) x~>baseName )
((atom car(x)) cons(list(sprintf(nil "%L" x~>baseName)) list((scope (cdr x))) ))
(t     
printf("MULT :%L\n" list(x~>baseName x~>cellName x~>master~>instances ))
printf("CAR :%L\n" (car x))
printf("CDR :%L\n" (cdr x))
(append sprintf(nil "%s.%s" (scope (car x)) (scope (cdr x)))))
))
scope(tree) ;=> (("(\"I1\" \"I0\" \"I2\" \"I3\")") "I1")


sprintf(nil "I1.%s") ("(\"I1\" \"I0\" \"I2\" \"I3\")") )
aList='("(\"I1\" \"I0\" \"I2\" \"I3\")")
mapcar( '(lambda (arg) sprintf(nil "I1.%s" arg )) aList)
bList='("I1" "I0" "I2" "I3")
mapcar( '(lambda (arg) sprintf(nil "I1.%s" arg )) bList)
mapcar( '(lambda (arg) sprintf(nil "I1.%s" arg )) bList)





(defun flatten (list) 
(cond
((null list) list)   ;=> nothing in the list anymore = stop condition
((null (car list)) (flatten (cdr list)))     ;=> first element is nil => ignore it and go further
((atom (car list)) (cons (car list) (flatten (cdr list))))  ; when first element is single process it (cons) and go further is returned
(t                 (append (flatten (car list)) (flatten (cdr list)))) ; else append head and tail with the function itself recursing
))

;;identical in two line definition
(defun flatten (list) (cond 
((null list) list) ((null (car list)) (flatten (cdr list))) ((atom (car list)) (cons (car list) (flatten (cdr list)))) (t (append (flatten (car list)) (flatten (cdr list))))))



master=geGetWindowCellView()
tree=master~>instances


(defun analyse (x)
(cond
((null x) printf("null %L" x) x)
((atom x) printf("atom %L" x) x)
((null car(x))&&(null cdr(x)) printf("null CAR&&CDR (ONE element nil in the list only) %L\n" x) x)
((null car(x)) printf("null CAR %L\n" x) x)
((atom car(x)) printf("atom CAR %L\n" x) x)
((length car(x))==1 printf("1 CAR %L\n" x) x)
((length car(x))==2 printf("2 CAR %L\n" x) x)
))
 
analyse(nil)       ;=> null nil 
analyse('(nil))    ;=> null car&&cds CAR (nil)
analyse('tata) ;=> atom tata
analyse(master) ;=> atom db:0x10adbf12 (master is defined=db:0x10adbf12)
analyse('(master)) ;=> atom CAR (master)
analyse('(master truc)) ;=> atom CAR (master truc)
analyse('(nil nil)) ;=> null CAR ((nil))
analyse('((nil))) ;=> 1 CAR ((nil))
analyse('((master) truc)) ;=> 1 CAR ((master) truc)
analyse('((master deux) truc)) ;=> 2 CAR ((master deux) truc)




;; PB infinit loop! check step by step
;; first caught condition transform the list into '((master upperInst[n-1] upperInst[n-2] upperInst[n-3] ...))
(defun scope (x)  
(let (shList downShapes trans inst upInstList box2trans tranList)
(cond
((null x) printf("null %L" x) x)
((atom x) printf("atom %L\n" x)
	foreach(mapcar inst x~>instances scope(list(inst~>master inst)))
	shList=setof(shape x~>shapes shape~>layerName=="MET1") 
	shList~>shapes~>bBox);<= revoie une liste de bBox
;master begin ^^^^^^^^^^
((null car(x))&&(null cdr(x)) x)
(t inst=car(x) upInstList=cdr(x)
;; shList=x~>shapes
shList=setof(shape x~>shapes shape~>layerName=="MET1") 
downBox=foreach(mapcar inst x~>instances scope(list(cons(inst~>master cons(inst cdr(x))))));<= recurse on following instances
shList=append(shList~>bBox downShapes)
printf("In master %s-%s transforming bBox shapes:\n" x~>baseName x~>cellName)
tranList=foreach(mapcar shape shList 
box2trans=shape~>bBox
printf("%L into->" box2trans)
foreach(mapcar upInst upInstList
box2trans=dbTransformBBox(box2trans upInst~>transform);; <== apply transform 
printf("%L by %L\n" box2trans upInst~>transform)
box2trans) tranList);;foreach foreach
);<= renvoie bBox et appele scope suivants
)))
scope(master) ;=> 



(defun flatten1Level (LIST) (if LIST (append (car LIST) (flatten1Level (cdr LIST)))  nil));;warning if LIST in not a list of list => fail
master=geGetWindowCellView()



aa=flatten1Level('(("A" "" ) ("B" "C")))
aa=flatten1Level(aa)

lst='(("A" "" ) ("B" (("A" "" ) ("B" "C")) "C"))
aa=flatten1Level(lst)


;; construct a list of traversed hierarchy instances: '((instance upperInst[n-1] upperInst[n-2] upperInst[n-3] ...))


LAYER_="PAD"
(defun scope (x)  
(let (shList downShapes trans inst box2trans tranList topRes)
(cond
((null x) printf("null %L" x) x)
((atom x) printf("atom %L\n" x)
when(null(LAYER_) printf("PLEASE DEFINE variable LAYER_ to a string layer. ie. \nLAYER_=%L\n" "PAD") return(2))
printf("scope(%L %L)________________\n" x LAYER_)
topRes=foreach(mapcar inst x~>instances scope(list(inst)));<= nil because no transformation or ((0 0) "R0" 1)
;;foreach(mapcar inst x~>instances scope(list(inst nil)));<= nil because no transformation or ((0 0) "R0" 1)
shList=setof(shape x~>shapes shape~>layerName==LAYER_) 
printf("shList %L\n" shList~>bBox)
printf("topRes='%L\n" topRes)
cons(list(shList~>bBox) topRes));<= revoie une liste de liste de bBox
;master begin ^^^^^^^^^^
((null car(x))&&(null cdr(x)) x)
(t inst=car(x)
shList=setof(shape inst~>master~>shapes shape~>layerName==LAYER_) 
printf("t: %L_%L-%L" x~>baseName x~>cellName x)
printf("\ttr%L" inst~>transform)
printf("\tsh: %L\n" inst~>master~>shapes)
toptopRes=foreach(mapcar ins inst~>master~>instances scope(cons(ins x)));qd list nil => pas d'evaluation de la suite => plus de recursion possible
tranList=foreach(mapcar shape shList 
box2trans=shape~>bBox
printf("\n%L through %L" box2trans x~>transform )
when(box2trans!=nil&&box2trans!='(nil)  ;;Warning when('(nil) crotte) =>passes => fails
printf("not-nil%L-%L" box2trans shape~>layerName)
foreach( upInst x when(upInst~>transform ;;<== PB with array : no transform... should I check  tileArray ("R0")?...skipped
box2trans=dbTransformBBox(box2trans upInst~>transform) );; <== apply transform 
);foreach transformations
);when box2trans
printf("boxTrans=%L\n" box2trans)
box2trans
); foreach
printf("AbsolutebBox %L\n" tranList)
printf("UPPERS__bBox %L\n" toptopRes)
cons(tranList flatten1Level(toptopRes))
))))
;;res=scope(master) ;=> 

hier=(dbOpenCellViewByType "Ed_IC6" "hier54" "layout")
aa=(dbOpenCellViewByType "IOLIB_4M" "CORNERP" "layout")
res=scope(hier) t
flatten1Level(flatten1Level(res))
res=scope(geGetWindowCellView()) t
ff=flatten1Level(flatten1Level(res))

bBox='((-0.45 -0.45) (0.45 0.45)) ;through (((36.45 79.95) "R0" 1.0) ((7.55 4.3) "R0" 1.0))
bBox=dbTransformBBox(bBox '((36.45 79.95) "R0" 1.0))
bBox=dbTransformBBox(bBox '((7.55 4.3) "R0" 1.0))

bBox=dbTransformBBox(nil '((7.55 4.3) "R0" 1.0))

dbTransformBBox('((0.0 43.5) (0.9 44.4)) '((0.45 43.95) "R0" 1.0))
toto='((1 2 3 4) "last")
'(one two)=toto
box2trans
when('(nil)!=nil&&nil!=nil crotte)

foreach( upInst '(nil ((7.55 4.3) "R0" 1.0)) printf("up:%L\n" upInst) if(upInst then;;<== PB with array : no transform... should I check  tileArray ("R0")?...skipped
printf("then %L %L " upInst box2trans) box2trans=dbTransformBBox(box2trans upInst)  else printf("else ") box2trans=nil);; <== apply transform 
) 



absSetOption "ImportVerilogFiles" "myverilogfile1" ;; ==> 1
absImportVerilog   ; ==> 1

Imports a Verilog file called myverilogfile1.
cat Work/IC6/.ihdlParamFile
absSetOption "ImportOptionsFile" ".ihdlParamFile"
Loading absGen.cxt 
*Error* arrayref: can't handle nil[nil]


use (system "") with :
$unix> ihdl -f option_file verilog_design_file
The option_file might contain the following:
-param ihdl_param_file
-v std_cell.v

ihdl -param .ihdlParamFile -v ~/Work/vhd/5decode/address_decoder_final.v
@(#)$CDS: ihdl.exe version 6.1.3 09/08/2008 02:38 (cic612lnx) $: (c) Copyright 1994-1995, Cadence Design Systems, Inc.
ERROR (VERILOGIN-75): Execution failed because you have not specified the design file to be imported. 
Specify a valid design file and run the command again.

ihdl -f -param .ihdlParamFile -v ~/Work/vhd/5decode/address_decoder_final.v
ihdl -help

ihdl ihdl -f option_file verilog_design_file


(defun take (n l)
  (cond (( n < 0) (error "index negative"))
        (( n == 0) ())
        ((null l) (error "index too large"))
        (t (cons (car l) (take (n-1) (cdr l))))))

;equivalent to :
aList='(a b c d e f) 
bList=reverse(nthcdr(length(aList)-3 reverse(aList))) 

alias(lf listFunctions)
lf("ToString") ;=> list all cmds with ToString
sortcar(list( '("A9" 45) '("C43" 56) '("B5" 23)) 'alphalessp);=> does not create a new list. Altered the input list

;; Trouver le cadran R0 R90 R180 ou R270 dans lequel se situe une intance   
;;  \/
;;  /\


pi=acos(-1);=> 3.141593
cv= geGetWindowCellView()
middle=centerBox(cv~>bBox);=>(2.040625 0.75)
ox=car(middle)
oy=cadr(middle)

norient=foreach(mapcar inst setof(in cv~>instances in~>purpose=="cell")
X=car(centerBox(inst~>bBox))
Y=cadr(centerBox(inst~>bBox))
if(X!=ox then
teta=180*atan((Y-oy)/(X-ox))/pi
when(X-ox<0 teta=teta+180)
tmp=mod(round(teta)+45+360 360)
list(inst~>name floor(tmp/90))
else if(Y-oy>0 1 0)
);end check notNaN
) t ;end loop inst

(sortcar norient 'alphalessp)


defun( orientSection (XY)
let((X Y teta tmp)
X=car(XY)
Y=cadr(XY)
if(X!=0 then
teta=180*atan(Y/X)/pi
when(X<0 teta=teta+180)
tmp=mod(round(teta)+45+360 360)
floor(tmp/90)
else if(Y>0 1 0)
)))

defun( orientSection (XY)
let((X Y teta)
X=car(XY)
Y=cadr(XY)
if(X!=0 then
teta=4*atan(Y/X)/pi
when(X<0 teta=teta+4)
floor(mod(round(teta)+9 8)/2)
else if(Y>0 1 0)
)))


;; suggestion for orientation text
middle=centerBox(geGetWindowCellView()~>bBox);=>(2.040625 0.75)
ox=car(middle) oy=cadr(middle)
norient=foreach(mapcar inst setof(in geGetWindowCellView()~>instances in~>purpose=="cell")
X=car(centerBox(inst~>bBox))
Y=cadr(centerBox(inst~>bBox))
list(inst~>name sprintf(nil "R%d" 90*orientSection(rodSubPoints(X:Y ox:oy) )))
)


cv=geGetWindowCellView()
hs = geCreateHilightSet( cv list("yellowLayerName" "drawing"))
geSetHilightSetHaloParameters(hs "over" "fadeout" "normal" 50 nil)
hs~>enable = t
geAddHilightPolygon( hs list(-2:-2 2:-2 2:2 -2:2) )

buildString( parseString("din<2>" "<>") "_") ;==> din_2  eleve chevron bus 

; fractionnal part
defun( part (x) x-floor(x))

x=19.7
rest=0 
rx=x*10

defun(intToPeri (x)
(let (rest x0 periList)
;; x0=truncate(10*(x-truncate(x))) ; why the Hell floor(0.7*10)=6 ! rounding error ?!
x0=atoi(sprintf(nil "%0.f" 0.7*10))
periList=reverse(foreach(mapcar peri reverse('(  1 2 5 10 20 50 100))
rest=floor(x/peri) x=x-peri*rest list(rest sprintf(nil "%d" peri) )))
cons(list(x0 "01") periList)
))

intToPeri(13.7) ;=> ((7 "01") (1 "1") (1 "2") (0 "5") (1 "10") (0 "20") (0 "50") (0 "100"))


defun(intToPeriSpacer (x)
foreach(mapcar n intToPeri(x) list(car(n) sprintf(nil "PERI_SPACER_%s_P" cadr(n))))) 
intToPeriSpacer(13.4);=> ((7 "PERI_SPACER_01_P") (1 "PERI_SPACER_1_P") (1 "PERI_SPACER_2_P") (0 "PERI_SPACER_5_P") (1 "PERI_SPACER_10_P") (0 "PERI_SPACER_20_P") (0 "PERI_SPACER_50_P") (0 "PERI_SPACER_100_P"))

; intToPeriSpacer(13.4)

defun(biggerPeri (x)
let((one) one=0
car(remove(nil foreach(mapcar p reverse(intToPeriSpacer(x)) if(car(p)!=0&&one==0 then one=1 cadr(p) else nil))))))

biggerPeri(5)

cv=geGetWindowCellView()

t0=cputime()
getMaxPointsLayer(cv "MET1")
t1=cputime()
t1-t0;=>158; en 60Ëme de secondes => 2.633 second

foreach(mapcar x '(1 2 3 4 5 6 7 8) mod((x+1)/2 2))
foreach(mapcar x '(1 2 3 4 5 6 7 8) mod(x/2 2))
foreach(mapcar x '(1 2 3 4 5 6 7 8) mod(x 2))


t0=cputime()
for(i 1 1M foreach(mapcar x '(1 2 3 4) mod((x+1)/2 2)))
t1=cputime() 
t1-t0; => 126

t0=cputime()
for(i 1 1M foreach(mapcar x '(1 2 3 4) if(x<=2 1 0)  ))
t1=cputime() 
t1-t0; => 94 Conclusion : if plus rapide que le mod... ;-(
dir="/the/path/you/want"
system(strcat("cd " dir "; xterm &"))

defun(test (@optional (cv "ZZ") @rest rest)
printf("ONE%L\n" cv)
printf("2NE_%L %d\n" rest length(rest))
if(metalList=assoc("metal" rest) METAL=cadr(metalList) METAL="MET1")
printf("GOT: %L\n" METAL)
)

test("TRUC"  '("" "metal1") '("metal" "metal2")  )
test("TRUC"  '("" "metal1") '("metal" )  )


output=nth(0 asiGetOutputList(asiGetCurrentSession()))
(cond (output~>type=='terminal
when(not(file=output~>name) file=output~>signal)
exprList='()
when(expr=IT(output~>signal) exprList=tconc(exprList expr))
when(expr=IDC(output~>signal) exprList=tconc(exprList expr))
exprList=car(exprList)
))


seuil=0.5
(cond
if(VT("/ADC_OUT<0>")>seuil 1 0)

awvPrintWaveform( ?output VT("/ADC_OUT<0>")

getData("loopGain" ?result "stb")

v("/ADC_OUT<0>" ?result "tran-tran")


;; OnlyPresentLayers ! like IBM 
procedure(JWgetUsedVisibleValidLayers(@optional (cv geGetEditCellView()))
  let(((tf techGetTechFile(cv)))
    setof(lp foreach(mapcar lpp cv~>lpps list(lpp~>layerName lpp~>purpose))
      leIsLayerValid(lp tf) && leIsLayerVisible(lp tf)
    )
  )
)



; print format pico nano micro mili kilo mega giga etc...
I1=1.9m ;=> 0.0019
I2=2.9m ;=> 0.0029
;=> 
cond(
(I1>=1e-3&&I1<1 sprintf(nil "%gm" I1*1e3))
(I1>=1e-6&&I1<1e-3 sprintf(nil "%gu" I1*1e6))
(I1>=1e-9&&I1<1e-6 sprintf(nil "%gn" I1*1e9))
(I1>=1e-12&&I1<1e-9 sprintf(nil "%gp" I1*1e12))
(t I1)
)
aelSuffixNotation(I2)

;; ssh pour remote host au lieu de ssh

envSetVal("asimenv.distributed" "remoteShell" 'string "ssh")
envGetVal("asimenv.distributed" "remoteShell" ) ;=> "ssh"


a='(1 2 3)
b='(4 5 6)

mapcan('list a b) ;=> (1 4 2 5 3 6)
mapcar('list a b) ;=> ((1 4) (2 5) (3 6))
